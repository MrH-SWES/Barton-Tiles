<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>Barton Reading Tile Board</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap"
    rel="stylesheet"
  />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Lexend', sans-serif; overflow: hidden; touch-action: none; }
    #app { display: flex; flex-direction: column; height: 100vh; background-color: #f3f4f6; }
    #wordPane { flex: 1; background-color: white; border-bottom: 4px solid #1f2937; padding: 20px; overflow: auto; position: relative; }
    #wordPane .hint { color: #9ca3af; text-align: center; margin-top: 80px; font-size: 18px; }
    #tileTray { background-color: #e5e7eb; border-top: 2px solid #9ca3af; overflow-y: auto; max-height: 45vh; }
    .tile { width: 60px; height: 60px; border: 2px solid #374151; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: center; font-weight: bold; user-select: none; box-shadow: 0 2px 4px rgba(0,0,0,0.2); touch-action: none; flex-shrink: 0; }
    .tile:active { cursor: grabbing; }
    .tile.blue { background-color: #60a5fa; }
    .tile.yellow { background-color: #fbbf24; }
    .tile.red { background-color: #f87171; }
    .tile.green { background-color: #4ade80; }
    .tile.orange { background-color: #fb923c; }
    .tile.purple { background-color: #a78bfa; }
    .tile.dragging { opacity: 0.9; position: fixed; z-index: 1000; pointer-events: none; }
    .alphabet-section { border-bottom: 2px solid #9ca3af; padding: 12px; }
    .lesson-selector-bar { display: flex; justify-content: center; align-items: center; gap: 10px; padding: 8px; background-color: #d1d5db; border-radius: 4px; margin-bottom: 12px; }
    .lesson-selector-bar label { font-weight: bold; }
    .lesson-selector-bar select { font-family: 'Lexend', sans-serif; font-size: 16px; padding: 4px; }
    .tile-row { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; }
    .drawer { border-bottom: 1px solid #9ca3af; }
    .drawer-header { width: 100%; background-color: #d1d5db; padding: 8px 16px; font-weight: bold; font-size: 18px; display: flex; align-items: center; justify-content: space-between; cursor: pointer; border: none; text-align: left; }
    .drawer-header:hover { background-color: #9ca3af; }
    .drawer-content { background-color: #f3f4f6; padding: 8px; display: none; }
    .drawer-content.open { display: flex; flex-wrap: wrap; gap: 4px; }
    .word-pane-tile { position: absolute; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="app">
    <div id="wordPane">
      <div class="hint">Drag tiles here to build words. Tap to hear the sound.</div>
    </div>

    <div id="tileTray">
      <div class="alphabet-section">
        <div class="lesson-selector-bar">
          <label for="lessonSelect">Select Level:</label>
          <select id="lessonSelect">
            <option value="2">Book 2: Consonants & Short Vowels</option>
            <option value="3">Book 3: Closed & Unit Syllables</option>
            <option value="4">Book 4: Vowel Teams</option>
            <option value="5">Book 5: Prefixes & Suffixes</option>
            <option value="6">Book 6: Silent-E</option>
            <option value="7">Book 7: Vowel-R</option>
            <option value="8">Book 8: Advanced Vowel Teams</option>
            <option value="9">Book 9: Foreign Influences</option>
            <option value="10">Book 10: Greek & Latin</option>
          </select>
        </div>
        <div class="tile-row" id="lessonTiles"></div>
      </div>

      <div class="drawer" id="drawer-units">
        <button class="drawer-header" data-drawer="wordUnits">
          <span>Glued Sounds & Units (Red)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="wordUnits"></div>
      </div>

      <div class="drawer" id="drawer-suffixes">
        <button class="drawer-header" data-drawer="affixes">
          <span>Suffixes (Green)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="affixes"></div>
      </div>

      <div class="drawer" id="drawer-prefixes">
        <button class="drawer-header" data-drawer="prefixes">
          <span>Prefixes & VCE Units (Orange)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="prefixes"></div>
      </div>

      <div class="drawer" id="drawer-roots">
        <button class="drawer-header" data-drawer="latin">
          <span>Latin & Greek Roots (Purple)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="latin"></div>
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const TILE_SIZE = 60;
    const SNAP_DISTANCE = 10;

    // Tap vs drag thresholds
    const DRAG_START_PX = 8;      // move > 8px => drag
    const TAP_MAX_TIME_MS = 250;  // up to 250ms => tap
    const TAP_MAX_MOVE_PX = 6;    // <6px movement => tap

    // Minimal grapheme=>"sound" strings to drive speechSynthesis.
    const PHONEME_MAP = {
      a: "ă", e: "ĕ", i: "ĭ", o: "ŏ", u: "ŭ",
      ch: "ch", sh: "sh", th: "th", wh: "hw", ck: "k",
      ph: "f", tch: "ch", dge: "j",
      ar: "ar", or: "or", er: "ər", ir: "ər", ur: "ər", ear: "eer",
      ai: "ā", ay: "ā", ee: "ē", ea: "ē", oa: "ō", oe: "ō", ue: "o͞o", ew: "o͞o", ow: "ō",
      oi: "oi", oy: "oi", au: "aw", aw: "aw", oo: "o͝o", ou: "ow", igh: "ī",
      ps: "s", rh: "r", mn: "n", wr: "r", kn: "n", gh: "g", gn: "n", que: "k", gu: "gw", gue: "g",
      b: "b", c: "k", d: "d", f: "f", g: "g", h: "h", j: "j", k: "k", l: "l", m: "m", n: "n",
      p: "p", qu: "kw", r: "r", s: "s", t: "t", v: "v", w: "w", x: "ks", y: "y", z: "z",
      y_vowel: "ĭ"
    };

    // Barton-style level sets
    const B_LEVELS = {
      2: { blue: ["b","c","d","f","g","h","j","k","l","m","n","p","qu","r","s","t","v","w","x","y","z","ch","ck","sh","th","wh"], yellow: ["a","e","i","o","u"] },
      3: { red: ["all","ang","ing","ong","ung","ank","ink","onk","unk","oll","old","olt","ost","ild","ind"] },
      4: { yellow: ["ai","ay","ee","oa","oe","ue","ew","ow"] },
      5: { green: ["s","es","ed","ing","er","est","ist","y","en","ish","ity","able","tion","sion"], orange: ["dis","in","un","non","mis","sub","re","pre","inter","mid","over","up"] },
      6: { blue: ["ph"], yellow: ["y"], red: ["ture"], green: ["ible","ble","cle","dle","fle","gle","kle","ple","tle","zle"], orange: ["ate","ite","ine","ice","ace","age"] },
      7: { yellow: ["ar","or","er","ir","ur","ear"], green: ["ary","ery","ory"] },
      8: { yellow: ["ie","oi","oy","ey","au","aw","oo","ou","ow","ea","igh","augh","eigh","ei","eu","tu"] },
      9: { blue: ["ps","rh","mn","wr","kn","gh","gn","que","gu","gue"], yellow: ["eau","our"], orange: ["age"] },
      10:{ purple: ["astro","auto","bio","chron","geo","graph","hydro","phon","tele","demo","fac","form","fort","fract","ject","jud","mal","mater","mit","mort","multi","pater","port","rupt","scrib","script","sect","sec","sent","spect","struct"] }
    };

    // ====== STATE ======
    let blueTiles = [], yellowTiles = [], redTiles = [], greenTiles = [], orangeTiles = [], purpleTiles = [];
    let tiles = [];                 // tiles on the pane
    let draggedTile = null;         // ephemeral drag meta
    let draggedGroup = [];          // members moving together
    let dragOffset = { x: 0, y: 0 };
    let gesture = null;             // tap vs drag
    let dragStartRowY = null;       // row y at drag start

    // ====== UTIL ======
    function getFontSize(text) {
      if (text.length <= 2) return '24px';
      if (text.length === 3) return '20px';
      if (text.length === 4) return '16px';
      if (text.length === 5) return '14px';
      return '12px';
    }

    function getUniqueSorted(arr) {
      return [...new Set(arr)].sort((a, b) => (a.length === b.length ? a.localeCompare(b) : a.length - b.length));
    }

    function sameRowY(y1, y2) { return Math.abs(y1 - y2) < TILE_SIZE / 2; }
    function areFlush(a, b, tol = 2) { return Math.abs(a.x + TILE_SIZE - b.x) <= tol; }

    // Recompute groupIds for the row around a given y
    function recomputeGroupsAround(rowY) {
      const row = tiles.filter(t => sameRowY(t.y, rowY)).sort((a,b) => a.x - b.x);
      let i = 0;
      while (i < row.length) {
        let j = i + 1;
        while (j < row.length && areFlush(row[j-1], row[j])) j++;
        const seg = row.slice(i, j);
        if (seg.length === 1) {
          seg[0].groupId = null;
        } else {
          const gid = seg[0].groupId || seg[0].id;
          for (const t of seg) t.groupId = gid;
        }
        i = j;
      }
    }

    // Get the full chain for a tile (use groupId if present; otherwise reconstruct by flush)
    function getGroupChain(main) {
      if (main.groupId) {
        return tiles
          .filter(t => t.groupId === main.groupId)
          .sort((a,b)=>a.x - b.x);
      }
      // reconstruct contiguous chain around main
      const row = tiles.filter(t => sameRowY(t.y, main.y)).sort((a,b)=>a.x-b.x);
      const idx = row.findIndex(t=>t.id===main.id);
      let L = idx, R = idx;
      while (L-1 >= 0 && areFlush(row[L-1], row[L])) L--;
      while (R+1 < row.length && areFlush(row[R], row[R+1])) R++;
      return row.slice(L, R+1);
    }

    function within(px, threshold) { return Math.abs(px) <= threshold; }

    // ====== AUDIO (placeholder: speech synthesis) ======
    function playPhoneme(grapheme, opts = {}) {
      const key = (grapheme === 'y' && opts.vowelY) ? 'y_vowel' : grapheme;
      const sound = PHONEME_MAP[key];
      if (!sound) return;
      if ('speechSynthesis' in window) {
        const u = new SpeechSynthesisUtterance(sound);
        u.lang = 'en-US';
        u.rate = 0.8;
        u.pitch = 1.0;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      }
    }

    // ====== DOM BUILDERS ======
    function createTile(text, color, source) {
      const tile = document.createElement('div');
      tile.className = `tile ${color}`;
      tile.textContent = text;
      tile.style.fontSize = getFontSize(text);
      tile.dataset.text = text;
      tile.dataset.color = color;
      tile.dataset.source = source;

      tile.addEventListener('mousedown', (e) => onPointerStart(e, text, color, source));
      tile.addEventListener('touchstart', (e) => onPointerStart(e, text, color, source), { passive: false });

      return tile;
    }

    function renderTray() {
      const selectedLevel = parseInt(document.getElementById('lessonSelect').value, 10);

      blueTiles = [];
      yellowTiles = [];
      redTiles = [];
      greenTiles = [];
      orangeTiles = [];
      purpleTiles = [];

      for (let i = 2; i <= selectedLevel; i++) {
        const L = B_LEVELS[i];
        if (!L) continue;
        if (L.blue)   blueTiles.push(...L.blue);
        if (L.yellow) yellowTiles.push(...L.yellow);
        if (L.red)    redTiles.push(...L.red);
        if (L.green)  greenTiles.push(...L.green);
        if (L.orange) orangeTiles.push(...L.orange);
        if (L.purple) purpleTiles.push(...L.purple);
      }

      blueTiles   = getUniqueSorted(blueTiles);
      yellowTiles = getUniqueSorted(yellowTiles);
      redTiles    = getUniqueSorted(redTiles);
      greenTiles  = getUniqueSorted(greenTiles);
      orangeTiles = getUniqueSorted(orangeTiles);
      purpleTiles = getUniqueSorted(purpleTiles);

      const lessonTilesEl = document.getElementById('lessonTiles');
      const wordUnitsEl   = document.getElementById('wordUnits');
      const affixesEl     = document.getElementById('affixes');
      const prefixesEl    = document.getElementById('prefixes');
      const latinEl       = document.getElementById('latin');
      lessonTilesEl.innerHTML = '';
      wordUnitsEl.innerHTML   = '';
      affixesEl.innerHTML     = '';
      prefixesEl.innerHTML    = '';
      latinEl.innerHTML       = '';

      // Alphabet row (A→Z with 'qu' occupying the q slot; no standalone 'q')
      const combinedBW  = [...blueTiles, ...yellowTiles];
      const singlesSet  = new Set(combinedBW.filter(t => t.length === 1));
      const hasQU       = combinedBW.includes('qu');
      const othersByLen = getUniqueSorted(combinedBW.filter(t => t.length > 1 && t !== 'qu'));

      const ALPHABET = Array.from({ length: 26 }, (_, i) => String.fromCharCode(97 + i));
      const orderedSingles = [];
      for (const ch of ALPHABET) {
        if (ch === 'q') {
          if (hasQU) orderedSingles.push('qu');
          continue;
        }
        if (singlesSet.has(ch)) orderedSingles.push(ch);
      }

      const alphaRow = document.createElement('div');
      alphaRow.className = 'tile-row';
      orderedSingles.forEach(txt => {
        const color = yellowTiles.includes(txt) ? 'yellow' : 'blue';
        alphaRow.appendChild(createTile(txt, color, 'tray'));
      });

      const graphemeRow = document.createElement('div');
      graphemeRow.className = 'tile-row';
      othersByLen.forEach(txt => {
        const color = yellowTiles.includes(txt) ? 'yellow' : 'blue';
        graphemeRow.appendChild(createTile(txt, color, 'tray'));
      });

      lessonTilesEl.appendChild(alphaRow);
      lessonTilesEl.appendChild(graphemeRow);

      const drawers = {
        units:    { elem: document.getElementById('drawer-units'),    tiles: redTiles,    color: 'red',    container: wordUnitsEl },
        suffixes: { elem: document.getElementById('drawer-suffixes'), tiles: greenTiles,  color: 'green',  container: affixesEl },
        prefixes: { elem: document.getElementById('drawer-prefixes'), tiles: orangeTiles, color: 'orange', container: prefixesEl },
        roots:    { elem: document.getElementById('drawer-roots'),    tiles: purpleTiles, color: 'purple', container: latinEl }
      };

      for (const key in drawers) {
        const d = drawers[key];
        if (d.tiles.length > 0) {
          d.elem.classList.remove('hidden');
          d.tiles.forEach(text => d.container.appendChild(createTile(text, d.color, 'tray')));
        } else {
          d.elem.classList.add('hidden');
          d.container.classList.remove('open');
          const arrow = d.elem.querySelector('.arrow');
          if (arrow) arrow.textContent = '▼';
        }
      }
    }

    function renderWordPane() {
      const wordPane = document.getElementById('wordPane');
      const hint = wordPane.querySelector('.hint');

      wordPane.querySelectorAll('.word-pane-tile').forEach(el => el.remove());
      hint.style.display = tiles.length > 0 ? 'none' : 'block';

      tiles.forEach(tile => {
        if (draggedGroup.find(t => t.id === tile.id)) return;

        const tileEl = document.createElement('div');
        tileEl.className = `tile ${tile.color} word-pane-tile`;
        tileEl.textContent = tile.text;
        tileEl.style.fontSize = getFontSize(tile.text);
        tileEl.style.left = tile.x + 'px';
        tileEl.style.top = tile.y + 'px';
        tileEl.dataset.id = tile.id;

        tileEl.addEventListener('mousedown', (e) => onPointerStart(e, tile.text, tile.color, tile.id));
        tileEl.addEventListener('touchstart', (e) => onPointerStart(e, tile.text, tile.color, tile.id), { passive: false });

        wordPane.appendChild(tileEl);
      });
    }

    // ====== LAYOUT / SNAP ======
    function findNearbyTiles(x, y, excludeId) {
      const nearby = [];
      tiles.forEach(tile => {
        if (tile.id === excludeId) return;
        if (sameRowY(tile.y, y)) {
          if (Math.abs((tile.x + TILE_SIZE) - x) < SNAP_DISTANCE) {
            nearby.push({ tile, edge: 'right', snapX: tile.x + TILE_SIZE, snapY: tile.y });
          }
          if (Math.abs(tile.x - (x + TILE_SIZE)) < SNAP_DISTANCE) {
            nearby.push({ tile, edge: 'left', snapX: tile.x - TILE_SIZE, snapY: tile.y });
          }
        }
      });
      nearby.sort((a, b) => Math.abs(a.snapX - x) - Math.abs(b.snapX - x));
      return nearby;
    }

    // ====== POINTER HANDLERS ======
    function onPointerStart(e, text, color, source) {
      e.preventDefault();
      e.stopPropagation();

      const point = e.touches ? e.touches[0] : e;
      const targetRect = e.currentTarget.getBoundingClientRect();
      const startX = point.clientX;
      const startY = point.clientY;
      const tStart = performance.now();

      gesture = {
        startX, startY, tStart,
        moved: false,
        lastX: startX, lastY: startY,
        source, text, color,
        onMove: null, onEnd: null,
      };

      gesture.onMove = (ev) => {
        const p = ev.touches ? ev.touches[0] : ev;
        const dx = p.clientX - gesture.startX;
        const dy = p.clientY - gesture.startY;
        gesture.lastX = p.clientX;
        gesture.lastY = p.clientY;

        if (!gesture.moved && (Math.abs(dx) > DRAG_START_PX || Math.abs(dy) > DRAG_START_PX)) {
          gesture.moved = true;
          // decide mode at the moment drag begins
          beginDrag(gesture, targetRect, dx, dy);
        }
        if (gesture.moved) handleMove(ev);
      };

      gesture.onEnd = (ev) => {
        const p = ev.changedTouches ? ev.changedTouches[0] : ev;
        const dt = performance.now() - gesture.tStart;
        const totalMove = Math.hypot(p.clientX - gesture.startX, p.clientY - gesture.startY);

        if (!gesture.moved && dt <= TAP_MAX_TIME_MS && totalMove <= TAP_MAX_MOVE_PX) {
          playPhoneme(text, { vowelY: (text === 'y' && isVowelYInScope()) });
          cleanupPointerListeners();
          gesture = null;
          return;
        }

        handleEnd(ev);
        cleanupPointerListeners();
        gesture = null;
      };

      document.addEventListener('mousemove', gesture.onMove, { passive: false });
      document.addEventListener('mouseup', gesture.onEnd, { passive: false });
      document.addEventListener('touchmove', gesture.onMove, { passive: false });
      document.addEventListener('touchend', gesture.onEnd, { passive: false });
    }

    function cleanupPointerListeners() {
      if (!gesture) return;
      document.removeEventListener('mousemove', gesture.onMove);
      document.removeEventListener('mouseup', gesture.onEnd);
      document.removeEventListener('touchmove', gesture.onMove);
      document.removeEventListener('touchend', gesture.onEnd);
    }

    function beginDrag(g, targetRect, dx = 0, dy = 0) {
      const startX = g.startX;
      const startY = g.startY;
      const source = g.source;

      if (source === 'tray') {
        draggedTile = { text: g.text, color: g.color, x: startX, y: startY, sourceType: 'tray', startX, startY };
        draggedGroup = [];
        dragStartRowY = null;
      } else {
        const paneTile = tiles.find(t => t.id === source);
        if (!paneTile) return;

        // Build the current contiguous chain containing the grabbed tile
        const chain = getGroupChain(paneTile);
        const idx = chain.findIndex(t => t.id === paneTile.id);

        // Decide split behavior: horizontal => take left or right block; vertical => single tile
        const horizontal = Math.abs(dx) >= Math.abs(dy); // 45° rule
        if (!horizontal) {
          // vertical pull-out: just the grabbed tile
          draggedGroup = [paneTile];
        } else if (dx < 0) {
          // moving left: take left side including the grabbed tile
          draggedGroup = chain.slice(0, idx + 1);
        } else {
          // moving right: take right side including the grabbed tile
          draggedGroup = chain.slice(idx);
        }

        draggedTile = { ...paneTile, x: startX, y: startY, sourceType: 'pane', startX, startY };
        dragStartRowY = paneTile.y;
      }

      dragOffset = { x: startX - targetRect.left, y: startY - targetRect.top };
      updateDragVisual();
    }

    function handleMove(e) {
      if (!draggedTile) return;
      e.preventDefault();

      const p = e.touches ? e.touches[0] : e;
      draggedTile.x = p.clientX;
      draggedTile.y = p.clientY;

      updateDragVisual();
    }

    function handleEnd(e) {
      if (!draggedTile) return;
      e.preventDefault();

      const p = e.changedTouches ? e.changedTouches[0] : e;
      const wordPane = document.getElementById('wordPane');
      const paneRect = wordPane.getBoundingClientRect();

      const insidePane = (
        p.clientX >= paneRect.left && p.clientX <= paneRect.right &&
        p.clientY >= paneRect.top  && p.clientY <= paneRect.bottom
      );

      if (insidePane) {
        const dropX = p.clientX - paneRect.left - dragOffset.x;
        const dropY = p.clientY - paneRect.top  - dragOffset.y;

        if (draggedTile.sourceType === 'tray') {
          const nearby = findNearbyTiles(dropX, dropY, null);
          let finalX = dropX, finalY = dropY, groupId = null;
          if (nearby.length > 0) {
            const closest = nearby[0];
            finalX = closest.snapX; finalY = closest.snapY;
            groupId = closest.tile.groupId || closest.tile.id;
          }
          const newTile = { id: Date.now() + Math.random(), text: draggedTile.text, color: draggedTile.color, x: finalX, y: finalY, groupId };
          tiles.push(newTile);
          recomputeGroupsAround(finalY);
        } else {
          if (draggedGroup.length > 0) {
            // main in the group before move
            const main = draggedGroup.find(gt => gt.id === draggedTile.id);
            const mainDropX = p.clientX - paneRect.left - (draggedTile.startX - main.x);
            const mainDropY = p.clientY - paneRect.top  - (draggedTile.startY - main.y);

            // Try snapping the main to a neighbor unit
            const nearMain = findNearbyTiles(mainDropX, mainDropY, draggedTile.id);
            let snapAdj = { dx: 0, dy: 0, groupId: null };
            if (nearMain.length > 0) {
              const closest = nearMain[0];
              snapAdj.dx = closest.snapX - mainDropX;
              snapAdj.dy = closest.snapY - mainDropY;
              snapAdj.groupId = closest.tile.groupId || closest.tile.id;
            }

            // Move only the selected subgroup
            tiles = tiles.map(t => {
              const inGroup = draggedGroup.some(gt => gt.id === t.id);
              if (!inGroup) return t;

              const mainBefore = draggedGroup.find(gt => gt.id === draggedTile.id);
              const offX = t.x - mainBefore.x;
              const offY = t.y - mainBefore.y;

              const newX = mainDropX + offX + snapAdj.dx;
              const newY = mainDropY + offY + snapAdj.dy;

              // if we snapped to a unit, inherit its groupId; otherwise clear for regroup
              return { ...t, x: newX, y: newY, groupId: snapAdj.groupId || null };
            });

            // Recompute groups on both origin and landing rows
            if (dragStartRowY !== null) recomputeGroupsAround(dragStartRowY);
            recomputeGroupsAround(mainDropY + snapAdj.dy);
          }
        }
      } else if (draggedTile.sourceType === 'pane') {
        // Dropped outside pane: delete dragged group and regroup origin row
        if (draggedGroup.length > 0) {
          const ids = new Set(draggedGroup.map(t => t.id));
          tiles = tiles.filter(t => !ids.has(t.id));
          if (dragStartRowY !== null) recomputeGroupsAround(dragStartRowY);
        }
      }

      draggedTile = null;
      draggedGroup = [];
      dragStartRowY = null;
      clearDragVisual();
      renderWordPane();
    }

    // ====== DRAG VISUALS ======
    function updateDragVisual() {
      clearDragVisual();
      if (!draggedTile) return;

      const wordPane = document.getElementById('wordPane');
      const paneRect = wordPane.getBoundingClientRect();

      if (draggedGroup.length > 0) {
        const dx = draggedTile.x - draggedTile.startX;
        const dy = draggedTile.y - draggedTile.startY;

        draggedGroup.forEach(tile => {
          const ghost = document.createElement('div');
          ghost.className = `tile ${tile.color} dragging`;
          ghost.textContent = tile.text;
          ghost.style.fontSize = getFontSize(tile.text);
          ghost.style.left = (tile.x + dx + paneRect.left) + 'px';
          ghost.style.top  = (tile.y + dy + paneRect.top)  + 'px';
          ghost.dataset.dragging = 'true';
          document.body.appendChild(ghost);
        });
      } else {
        const ghost = document.createElement('div');
        ghost.className = `tile ${draggedTile.color} dragging`;
        ghost.textContent = draggedTile.text;
        ghost.style.fontSize = getFontSize(draggedTile.text);
        ghost.style.left = (draggedTile.x - dragOffset.x) + 'px';
        ghost.style.top  = (draggedTile.y - dragOffset.y) + 'px';
        ghost.dataset.dragging = 'true';
        document.body.appendChild(ghost);
      }

      renderWordPane();
    }

    function clearDragVisual() {
      document.querySelectorAll('[data-dragging="true"]').forEach(el => el.remove());
    }

    // ====== HELPERS ======
    function isVowelYInScope() {
      const selectedLevel = parseInt(document.getElementById('lessonSelect').value, 10);
      if (selectedLevel < 6) return false;
      const lvl6 = B_LEVELS[6];
      return !!(lvl6 && lvl6.yellow && lvl6.yellow.includes('y'));
    }

    // ====== BOOT ======
    document.querySelectorAll('.drawer-header').forEach(header => {
      header.addEventListener('click', (e) => {
        const drawer = e.currentTarget.closest('.drawer');
        const content = drawer.querySelector('.drawer-content');
        const arrow = e.currentTarget.querySelector('.arrow');
        if (content.classList.contains('open')) {
          content.classList.remove('open'); arrow.textContent = '▼';
        } else {
          content.classList.add('open'); arrow.textContent = '▲';
        }
      });
    });

    document.getElementById('lessonSelect').addEventListener('change', renderTray);

    renderTray();
    renderWordPane();
  </script>
</body>
</html>
