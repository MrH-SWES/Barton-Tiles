<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
  />
  <title>Barton Reading Tile Board — Beta</title>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #0f3e72;
      --pane: #ffffff;
      --ink: #111827;
      --tray: #5b2a86;
      --tab: #8b5cf6;
      --tab-dim: #9f7aea;
      --tab-ink: #fff;
      --shadow: rgba(0,0,0,.25);
    }

    body { font-family: 'Lexend', sans-serif; background: var(--bg); color: var(--ink); height: 100vh; overflow: hidden; touch-action: manipulation; }

    #app { position: relative; height: 100%; width: 100%; }

    /* Workspace (free canvas) */
    #wordPane {
      position: absolute;
      inset: 0 0 160px 0; /* leave room for bottom drawers */
      background: transparent;
      overflow: hidden;
    }

    /* Syllaboard box (appears only in syllaboard mode) */
    #syllaboardBox {
      position: absolute;
      left: 50%;
      top: 42%;
      transform: translateX(-50%);
      width: min(720px, 86vw);
      height: 120px;
      background: #fff;
      border-radius: 8px;
      border: 4px solid #222;
      box-shadow: 0 6px 16px var(--shadow);
      display: none;
    }
    #syllaboardBox.on { display: block; }

    .hint {
      position: absolute;
      left: 50%;
      top: 46%;
      transform: translate(-50%,-50%);
      color: #e5e7eb;
      font-size: 18px;
      text-align: center;
      pointer-events: none;
    }

    /* Tiles */
    .tile {
      width: 60px;
      height: 60px;
      border: 2px solid #374151;
      border-radius: 6px;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      user-select: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.25);
      flex-shrink: 0;
      touch-action: none;
    }
    .tile:active { cursor: grabbing; }
    .tile.blue   { background-color: #60a5fa; }
    .tile.yellow { background-color: #fbbf24; }
    .tile.red    { background-color: #f87171; }
    .tile.green  { background-color: #4ade80; }
    .tile.orange { background-color: #fb923c; }
    .tile.purple { background-color: #a78bfa; }

    .tile.dragging {
      position: fixed;
      z-index: 1000;
      opacity: .95;
      pointer-events: none;
      will-change: transform;
      left: 0; top: 0;
    }

    .word-pane-tile { position: absolute; }

    /* Top controls */
    #controls {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    .btn {
      background: #111827;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 2px 6px var(--shadow);
    }
    .btn.secondary { background: #374151; }
    .btn.danger    { background: #dc2626; }

    /* Bottom drawers (pull-up tabs) */
    #bottomDock {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      height: 160px; /* collapsed height incl. tabs */
      pointer-events: none; /* children re-enable */
    }

    .drawerRow {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      display: flex;
      gap: 10px;
      padding: 10px 14px;
      justify-content: flex-start;
      pointer-events: auto;
    }

    .drawer {
      position: relative;
      width: 360px;
      max-width: 46vw;
    }

    .tab {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      height: 40px;
      background: var(--tab);
      border-radius: 10px 10px 0 0;
      color: var(--tab-ink);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      letter-spacing: .2px;
      box-shadow: 0 -2px 6px rgba(0,0,0,.2), 0 3px 8px var(--shadow);
      cursor: pointer;
      user-select: none;
      z-index: 2;
    }
    .tab.dim { background: var(--tab-dim); }

    .drawerContent {
      position: absolute;
      left: 0; right: 0;
      bottom: 40px; /* sits just above tab */
      background: var(--tray);
      border-radius: 12px 12px 0 0;
      padding: 10px;
      box-shadow: 0 -6px 12px rgba(0,0,0,.35);
      overflow: hidden;
      transform: translateY(100%);
      max-height: 0;
      transition: transform .25s ease, max-height .25s ease;
    }
    .drawer.open .drawerContent {
      transform: translateY(0%);
      max-height: 320px;
    }

    .tile-row { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }

    .legend {
      color: #e9d5ff; font-size: 12px; margin: 4px 0 8px; text-align: center;
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="app">
    <div id="wordPane">
      <div id="syllaboardBox"></div>
      <div class="hint">Drag tiles here to build words. Tap a unit to hear it.</div>
      <div id="controls">
        <button id="toggleSyllaboard" class="btn">Syllaboard: Off</button>
        <select id="lessonSelect" class="btn secondary">
          <option value="2">Book 2</option>
          <option value="3">Book 3</option>
          <option value="4">Book 4</option>
          <option value="5">Book 5</option>
          <option value="6">Book 6</option>
          <option value="7">Book 7</option>
          <option value="8">Book 8</option>
          <option value="9">Book 9</option>
          <option value="10">Book 10</option>
        </select>
        <button id="resetButton" class="btn danger">Reset</button>
      </div>
    </div>

    <!-- Bottom pull-up drawers -->
    <div id="bottomDock">
      <div class="drawerRow">

        <div class="drawer" id="drawer-alphabet">
          <div class="tab">Basic Tiles</div>
          <div class="drawerContent">
            <div class="legend">A–Z (with “qu” in the Q slot) and common graphemes</div>
            <div class="tile-row" id="lessonTiles"></div>
          </div>
        </div>

        <div class="drawer" id="drawer-units">
          <div class="tab dim">Units</div>
          <div class="drawerContent">
            <div class="tile-row" id="wordUnits"></div>
          </div>
        </div>

        <div class="drawer" id="drawer-affixes">
          <div class="tab dim">Suffixes / Prefixes</div>
          <div class="drawerContent">
            <div class="tile-row" id="affixes"></div>
            <div class="tile-row" id="prefixes" style="margin-top:10px;"></div>
          </div>
        </div>

        <div class="drawer" id="drawer-roots">
          <div class="tab dim">Greek / Latin Roots</div>
          <div class="drawerContent">
            <div class="tile-row" id="latin"></div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const TILE_SIZE = 60;

    // Touch-friendly snapping
    const SNAP_DISTANCE = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) ? 16 : 10;

    // Seam insertion capture width
    const SEAM_CAPTURE = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) ? 22 : 14;

    // require some vertical overlap between tiles for a snap to be valid
    const MIN_VERTICAL_OVERLAP = Math.floor(TILE_SIZE * 0.33);

    // Drag thresholds
    function dragThresholdFor(e) { return (e && e.pointerType === 'touch') ? 12 : 6; }

    // Tap detection
    const TAP_MAX_TIME_MS = 250;
    const TAP_MAX_MOVE_PX = 6;

    // Syllaboard constants
    let SYLLABOARD_MODE = false;
    const SYLLA_ROW_Y = 50; // y inside the syllaboard box

    // ====== AUDIO: files preferred for single grapheme taps (tray) ======
    const AUDIO_MAP = {
      "a": "/audio/a.mp3","e":"/audio/e.mp3","i":"/audio/i.mp3","o":"/audio/o.mp3","u":"/audio/u.mp3",
      "b":"/audio/b.mp3","c":"/audio/c.mp3","d":"/audio/d.mp3","f":"/audio/f.mp3","g":"/audio/g.mp3",
      "h":"/audio/h.mp3","j":"/audio/j.mp3","k":"/audio/k.mp3","l":"/audio/l.mp3","m":"/audio/m.mp3",
      "n":"/audio/n.mp3","p":"/audio/p.mp3","qu":"/audio/qu.mp3","r":"/audio/r.mp3","s":"/audio/s.mp3",
      "t":"/audio/t.mp3","v":"/audio/v.mp3","w":"/audio/w.mp3","x":"/audio/x.mp3","y":"/audio/y_consonant.mp3",
      "z":"/audio/z.mp3",
      "ch":"/audio/ch.mp3","sh":"/audio/sh.mp3","th":"/audio/th.mp3","wh":"/audio/wh.mp3",
      "ar":"/audio/ar.mp3","or":"/audio/or.mp3","er":"/audio/er.mp3","ir":"/audio/ir.mp3","ur":"/audio/ur.mp3",
      "ai":"/audio/ai.mp3","ay":"/audio/ay.mp3","ee":"/audio/ee.mp3","oa":"/audio/oa.mp3","igh":"/audio/igh.mp3",
      "y_vowel":"/audio/y_vowel.mp3"
    };
    const _audioCache = new Map();
    function getAudio(key){ const url = AUDIO_MAP[key]; if(!url) return null; if(_audioCache.has(url)) return _audioCache.get(url); const el=new Audio(url); el.preload="auto"; _audioCache.set(url,el); return el; }
    window.addEventListener("load",()=>["a","e","i","o","u","ch","sh","th","qu"].forEach(k=>{const a=getAudio(k); if(a){try{a.load();}catch(_){}}}));

    const PHONEME_TTS = {
      a:"ă",e:"ĕ",i:"ĭ",o:"ŏ",u:"ŭ",
      ch:"ch",sh:"sh",th:"th",wh:"hw",ck:"k",ph:"f",tch:"ch",dge:"j",
      ar:"ar",or:"or",er:"ər",ir:"ər",ur:"ər",ear:"eer",
      ai:"ā",ay:"ā",ee:"ē",ea:"ē",oa:"ō",oe:"ō",ue:"o͞o",ew:"o͞o",ow:"ō",
      oi:"oi",oy:"oi",au:"aw",aw:"aw",oo:"o͝o",ou:"ow",igh:"ī",
      ps:"s",rh:"r",mn:"n",wr:"r",kn:"n",gh:"g",gn:"n",que:"k",gu:"gw",gue:"g",
      b:"b",c:"k",d:"d",f:"f",g:"g",h:"h",j:"j",k:"k",l:"l",m:"m",n:"n",
      p:"p",qu:"kw",r:"r",s:"s",t:"t",v:"v",w:"w",x:"ks",y:"y",z:"z", y_vowel:"ĭ"
    };

    function speakTTS(text){
      if(!text) return;
      if("speechSynthesis" in window){
        try{ const u=new SpeechSynthesisUtterance(text); u.lang="en-US"; u.rate=.9; u.pitch=1; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);}catch(_){}
      }
    }
    function playPhoneme(grapheme,opts={}) {
      const key=(grapheme==='y'&&opts.vowelY)?'y_vowel':grapheme;
      const a=getAudio(key);
      if(a){ try{ _audioCache.forEach(x=>{ if(!x.paused && x!==a){ try{x.pause(); x.currentTime=0;}catch(_){}}}); a.currentTime=0; a.play().catch(()=>speakTTS(PHONEME_TTS[key]||key)); return; }catch(_){ } }
      speakTTS(PHONEME_TTS[key]||key);
    }
    function speakUnitForTileId(id){
      const t=tiles.find(x=>x.id===id); if(!t) return;
      const chain=getGroupChain(t);
      const text=chain.map(x=>x.text).join('');
      speakTTS(text);
    }

    // ====== LEVEL DATA ======
    const B_LEVELS = {
      2: { blue: ["b","c","d","f","g","h","j","k","l","m","n","p","qu","r","s","t","v","w","x","y","z","ch","ck","sh","th","wh"], yellow: ["a","e","i","o","u"] },
      3: { red: ["all","ang","ing","ong","ung","ank","ink","onk","unk","oll","old","olt","ost","ild","ind"] },
      4: { yellow: ["ai","ay","ee","oa","oe","ue","ew","ow"] },
      5: { green: ["s","es","ed","ing","er","est","ist","y","en","ish","ity","able","tion","sion"], orange: ["dis","in","un","non","mis","sub","re","pre","inter","mid","over","up"] },
      6: { blue: ["ph"], yellow: ["y"], red: ["ture"], green: ["ible","ble","cle","dle","fle","gle","kle","ple","tle","zle"], orange: ["ate","ite","ine","ice","ace","age"] },
      7: { yellow: ["ar","or","er","ir","ur","ear"], green: ["ary","ery","ory"] },
      8: { yellow: ["ie","oi","oy","ey","au","aw","oo","ou","ow","ea","igh","augh","eigh","ei","eu","tu"] },
      9: { blue: ["ps","rh","mn","wr","kn","gh","gn","que","gu","gue"], yellow: ["eau","our"], orange: ["age"] },
      10:{ purple: ["astro","auto","bio","chron","geo","graph","hydro","phon","tele","demo","fac","form","fort","fract","ject","jud","mal","mater","mit","mort","multi","pater","port","rupt","scrib","script","sect","sec","sent","spect","struct"] }
    };

    // ====== STATE ======
    let blueTiles=[], yellowTiles=[], redTiles=[], greenTiles=[], orangeTiles=[], purpleTiles=[];
    let tiles=[]; // on pane
    let draggedTile=null;
    let draggedGroup=[];
    let dragOffset={x:0,y:0};
    let gesture=null;
    let dragStartRowY=null;

    // ====== UTIL ======
    function getFontSize(text){
      if(text.length<=2) return '24px';
      if(text.length===3) return '20px';
      if(text.length===4) return '16px';
      if(text.length===5) return '14px';
      return '12px';
    }
    function getUniqueSorted(arr){ return [...new Set(arr)].sort((a,b)=> (a.length===b.length ? a.localeCompare(b) : a.length-b.length)); }
    function sameRowY(y1,y2){ return Math.abs(y1-y2) < TILE_SIZE/2; }
    function areFlush(a,b,tol=2){ return Math.abs(a.x + TILE_SIZE - b.x) <= tol; }

    function recomputeGroupsAround(rowY){
      const row=tiles.filter(t=>sameRowY(t.y,rowY)).sort((a,b)=>a.x-b.x);
      let i=0;
      while(i<row.length){
        let j=i+1;
        while(j<row.length && areFlush(row[j-1],row[j])) j++;
        const seg=row.slice(i,j);
        if(seg.length===1) seg[0].groupId=null;
        else { const gid=seg[0].groupId || seg[0].id; seg.forEach(t=>t.groupId=gid); }
        i=j;
      }
    }

    function getGroupChain(main){
      const row=tiles.filter(t=>sameRowY(t.y,main.y)).sort((a,b)=>a.x-b.x);
      const idx=row.findIndex(t=>t.id===main.id); if(idx===-1) return [main];
      let L=idx; while(L-1>=0 && areFlush(row[L-1],row[L])) L--;
      let R=idx; while(R+1<row.length && areFlush(row[R],row[R+1])) R++;
      return row.slice(L,R+1);
    }

    // ====== SEAM INSERTION ======
    function findSeamNear(dropX, dropY){
      const row=tiles.filter(t=>sameRowY(t.y, dropY)).sort((a,b)=>a.x-b.x);
      for(let i=0;i<row.length-1;i++){
        const L=row[i], R=row[i+1];
        if(!areFlush(L,R)) continue;
        const seamX=L.x + TILE_SIZE;
        if(Math.abs(dropX - seamX) <= SEAM_CAPTURE){
          return { left:L, right:R, seamX, rowY:L.y };
        }
      }
      return null;
    }

    function insertAtSeam(newTileData, seam){
      const {right,rowY}=seam;
      const rightSide=tiles.filter(t=>sameRowY(t.y,rowY) && t.x>=right.x).sort((a,b)=>a.x-b.x);
      rightSide.forEach(t=>{ t.x += TILE_SIZE; });
      const newTile={ id: Date.now()+Math.random(), text:newTileData.text, color:newTileData.color, x: right.x - TILE_SIZE, y: rowY, groupId:null };
      tiles.push(newTile);
      recomputeGroupsAround(rowY);
    }

    // ====== DRAWERS ======
    function setupDrawers(){
      document.querySelectorAll('.drawer .tab').forEach(tab=>{
        tab.addEventListener('click', ()=>{
          const drawer=tab.parentElement;
          const openNow=drawer.classList.contains('open');
          document.querySelectorAll('.drawer').forEach(d=>d.classList.remove('open'));
          if(!openNow) drawer.classList.add('open');
        });
      });
      // open the first drawer by default
      document.getElementById('drawer-alphabet').classList.add('open');
    }

    // ====== DOM BUILDERS ======
    function createTile(text,color,source){
      const el=document.createElement('div');
      el.className=`tile ${color}`;
      el.textContent=text;
      el.style.fontSize=getFontSize(text);
      el.dataset.text=text;
      el.dataset.color=color;
      el.dataset.source=source;
      el.addEventListener('pointerdown', (e)=>onPointerStart(e,text,color,source));
      return el;
    }

    function renderTray(){
      const lvl=parseInt(document.getElementById('lessonSelect').value,10);
      blueTiles=[]; yellowTiles=[]; redTiles=[]; greenTiles=[]; orangeTiles=[]; purpleTiles=[];
      for(let i=2;i<=lvl;i++){
        const L=B_LEVELS[i]; if(!L) continue;
        if(L.blue)   blueTiles.push(...L.blue);
        if(L.yellow) yellowTiles.push(...L.yellow);
        if(L.red)    redTiles.push(...L.red);
        if(L.green)  greenTiles.push(...L.green);
        if(L.orange) orangeTiles.push(...L.orange);
        if(L.purple) purpleTiles.push(...L.purple);
      }
      blueTiles=getUniqueSorted(blueTiles);
      yellowTiles=getUniqueSorted(yellowTiles);
      redTiles=getUniqueSorted(redTiles);
      greenTiles=getUniqueSorted(greenTiles);
      orangeTiles=getUniqueSorted(orangeTiles);
      purpleTiles=getUniqueSorted(purpleTiles);

      const lessonTilesEl=document.getElementById('lessonTiles');
      const wordUnitsEl=document.getElementById('wordUnits');
      const affixesEl=document.getElementById('affixes');
      const prefixesEl=document.getElementById('prefixes');
      const latinEl=document.getElementById('latin');
      lessonTilesEl.innerHTML=''; wordUnitsEl.innerHTML=''; affixesEl.innerHTML=''; prefixesEl.innerHTML=''; latinEl.innerHTML='';

      // Alphabet with qu
      const combined=[...blueTiles, ...yellowTiles];
      const singles=new Set(combined.filter(t=>t.length===1));
      const hasQU=combined.includes('qu');
      const others=getUniqueSorted(combined.filter(t=>t.length>1 && t!=='qu'));

      const ALPH=Array.from({length:26},(_,i)=>String.fromCharCode(97+i));
      const ordered=[];
      for(const ch of ALPH){ if(ch==='q'){ if(hasQU) ordered.push('qu'); continue; } if(singles.has(ch)) ordered.push(ch); }

      const alphaRow=document.createElement('div'); alphaRow.className='tile-row';
      ordered.forEach(txt=> alphaRow.appendChild(createTile(txt, yellowTiles.includes(txt)?'yellow':'blue', 'tray')));

      const graphemeRow=document.createElement('div'); graphemeRow.className='tile-row'; graphemeRow.style.marginTop='8px';
      others.forEach(txt=> graphemeRow.appendChild(createTile(txt, yellowTiles.includes(txt)?'yellow':'blue', 'tray')));

      lessonTilesEl.appendChild(alphaRow);
      lessonTilesEl.appendChild(graphemeRow);

      redTiles.forEach(t=> wordUnitsEl.appendChild(createTile(t,'red','tray')));
      greenTiles.forEach(t=> affixesEl.appendChild(createTile(t,'green','tray')));
      orangeTiles.forEach(t=> prefixesEl.appendChild(createTile(t,'orange','tray')));
      purpleTiles.forEach(t=> latinEl.appendChild(createTile(t,'purple','tray')));
    }

    function renderWordPane(){
      const wordPane=document.getElementById('wordPane');
      const hint=wordPane.querySelector('.hint');
      wordPane.querySelectorAll('.word-pane-tile').forEach(el=>el.remove());
      hint.style.display = tiles.length>0 ? 'none' : 'block';

      // Syllaboard box visibility
      document.getElementById('syllaboardBox').classList.toggle('on', SYLLABOARD_MODE);

      tiles.forEach(tile=>{
        if(draggedGroup.find(t=>t.id===tile.id)) return;
        const el=document.createElement('div');
        el.className=`tile ${tile.color} word-pane-tile`;
        el.textContent=tile.text;
        el.style.fontSize=getFontSize(tile.text);
        el.style.left=tile.x+'px';
        el.style.top=tile.y+'px';
        el.dataset.id=tile.id;
        el.addEventListener('pointerdown',(e)=>onPointerStart(e,tile.text,tile.color,tile.id));
        wordPane.appendChild(el);
      });
    }

    // ====== SNAP (edge-touch with vertical-overlap) ======
    function findNearbyTiles(dropX, dropY, excludeId){
      const dragLeft=dropX, dragRight=dropX+TILE_SIZE, dragTop=dropY, dragBottom=dropY+TILE_SIZE;
      const candidates=[];
      for(const tile of tiles){
        if(tile.id===excludeId) continue;
        const nbrLeft=tile.x, nbrRight=tile.x+TILE_SIZE, nbrTop=tile.y, nbrBottom=tile.y+TILE_SIZE;
        const overlapY=Math.min(dragBottom,nbrBottom) - Math.max(dragTop,nbrTop);
        if(overlapY<=0 || overlapY<MIN_VERTICAL_OVERLAP) continue;

        const leftGap=Math.abs(nbrRight - dragLeft);
        if(leftGap<=SNAP_DISTANCE){
          candidates.push({ tile, edge:'right', snapX:nbrRight, snapY: SYLLABOARD_MODE ? tile.y : tile.y });
        }
        const rightGap=Math.abs(nbrLeft - dragRight);
        if(rightGap<=SNAP_DISTANCE){
          candidates.push({ tile, edge:'left', snapX:nbrLeft - TILE_SIZE, snapY: SYLLABOARD_MODE ? tile.y : tile.y });
        }
      }
      candidates.sort((a,b)=>{
        const ax=Math.abs(a.edge==='right'?(a.tile.x+TILE_SIZE)-dragLeft: a.tile.x - dragRight);
        const bx=Math.abs(b.edge==='right'?(b.tile.x+TILE_SIZE)-dragLeft: b.tile.x - dragRight);
        if(ax!==bx) return ax-bx;
        const ay=Math.abs(a.snapY - dropY), by=Math.abs(b.snapY - dropY);
        return ay - by;
      });
      return candidates;
    }

    // ====== POINTER HANDLERS ======
    function onPointerStart(e,text,color,source){
      if(e.isPrimary===false) return;
      e.preventDefault(); e.stopPropagation();
      if(e.currentTarget.setPointerCapture){ try{ e.currentTarget.setPointerCapture(e.pointerId); }catch(_){ } }

      const targetRect=e.currentTarget.getBoundingClientRect();
      const startX=e.clientX, startY=e.clientY, tStart=performance.now();

      gesture={ startX, startY, tStart, moved:false, lastX:startX, lastY:startY, source, text, color, pointerType:e.pointerType, onMove:null, onEnd:null };

      gesture.onMove=(ev)=>{
        const dx=ev.clientX - gesture.startX;
        const dy=ev.clientY - gesture.startY;
        gesture.lastX=ev.clientX; gesture.lastY=ev.clientY;
        const threshold=dragThresholdFor(ev);
        if(!gesture.moved && (Math.abs(dx)>threshold || Math.abs(dy)>threshold)){
          gesture.moved=true; beginDrag(gesture, targetRect, dx, dy);
        }
        if(gesture.moved) handleMove(ev);
      };

      gesture.onEnd=(ev)=>{
        const dt=performance.now()-gesture.tStart;
        const totalMove=Math.hypot(ev.clientX-gesture.startX, ev.clientY-gesture.startY);
        if(!gesture.moved && dt<=TAP_MAX_TIME_MS && totalMove<=TAP_MAX_MOVE_PX){
          if(gesture.source!=='tray') speakUnitForTileId(gesture.source);
          else playPhoneme(text, { vowelY:(text==='y' && isVowelYInScope()) });
          cleanupPointerListeners(); gesture=null; return;
        }
        handleEnd(ev);
        cleanupPointerListeners();
        gesture=null;
      };

      document.addEventListener('pointermove', gesture.onMove, {passive:false});
      document.addEventListener('pointerup',   gesture.onEnd,  {passive:false});
      document.addEventListener('pointercancel', gesture.onEnd, {passive:false});
    }

    function cleanupPointerListeners(){
      if(!gesture) return;
      document.removeEventListener('pointermove', gesture.onMove);
      document.removeEventListener('pointerup', gesture.onEnd);
      document.removeEventListener('pointercancel', gesture.onEnd);
    }

    function beginDrag(g, targetRect, dx=0, dy=0){
      const startX=g.startX, startY=g.startY, source=g.source;

      if(source==='tray'){
        draggedTile={ text:g.text, color:g.color, x:startX, y:startY, sourceType:'tray', startX, startY };
        draggedGroup=[]; dragStartRowY=null;
      } else {
        const paneTile=tiles.find(t=>t.id===source); if(!paneTile) return;
        const chain=getGroupChain(paneTile);
        const idx=chain.findIndex(t=>t.id===paneTile.id);
        const horizontal=Math.abs(dx) >= Math.abs(dy);
        if(!horizontal) draggedGroup=[paneTile];
        else if(dx<0)   draggedGroup=chain.slice(0, idx+1);
        else            draggedGroup=chain.slice(idx);

        draggedTile={ ...paneTile, x:startX, y:startY, sourceType:'pane', startX, startY };
        dragStartRowY=paneTile.y;
      }

      dragOffset={ x:startX - targetRect.left, y:startY - targetRect.top };
      updateDragVisual();
    }

    function handleMove(e){
      if(!draggedTile) return;
      e.preventDefault();
      draggedTile.x=e.clientX; draggedTile.y=e.clientY;
      updateDragVisual();
    }

    function handleEnd(e){
      if(!draggedTile) return;
      e.preventDefault();

      const wordPane=document.getElementById('wordPane');
      const paneRect=wordPane.getBoundingClientRect();

      const inside = e.clientX>=paneRect.left && e.clientX<=paneRect.right && e.clientY>=paneRect.top && e.clientY<=paneRect.bottom;

      if(inside){
        // drop position in pane coords
        let dropX=e.clientX - paneRect.left - dragOffset.x;
        let dropY=e.clientY - paneRect.top  - dragOffset.y;

        if(SYLLABOARD_MODE) dropY = SYLLA_ROW_Y;

        if(draggedTile.sourceType==='tray'){
          // seam first (row restricted in syllaboard mode)
          const seam = findSeamNear(dropY, dropY) || findSeamNear(dropX, dropY);
          if(seam && (!SYLLABOARD_MODE || sameRowY(seam.rowY, SYLLA_ROW_Y))){
            insertAtSeam({text:draggedTile.text, color:draggedTile.color}, seam);
            finishDrop(); return;
          }

          const nearby=findNearbyTiles(dropX, dropY, null);
          let finalX=dropX, finalY=dropY, groupId=null;
          if(nearby.length>0){
            const closest=nearby[0];
            finalX=closest.snapX; finalY = SYLLABOARD_MODE ? SYLLA_ROW_Y : closest.snapY;
            groupId=closest.tile.groupId || closest.tile.id;
          }
          const newTile={ id:Date.now()+Math.random(), text:draggedTile.text, color:draggedTile.color, x:finalX, y:finalY, groupId };
          tiles.push(newTile);
          recomputeGroupsAround(finalY);
        } else {
          if(draggedGroup.length>0){
            // single-tile: allow seam
            if(draggedGroup.length===1){
              const seam=findSeamNear(dropX, dropY);
              if(seam && (!SYLLABOARD_MODE || sameRowY(seam.rowY, SYLLA_ROW_Y))){
                const only=draggedGroup[0]; const originY=only.y;
                tiles = tiles.filter(t=>t.id!==only.id);
                if(dragStartRowY!==null) recomputeGroupsAround(originY);
                insertAtSeam({text:only.text, color:only.color}, seam);
                finishDrop(); return;
              }
            }

            const main=draggedGroup.find(gt=>gt.id===draggedTile.id);
            const mainDropX = e.clientX - paneRect.left - (draggedTile.startX - main.x);
            const mainDropY = (SYLLABOARD_MODE ? SYLLA_ROW_Y : (e.clientY - paneRect.top - (draggedTile.startY - main.y)));

            const nearMain=findNearbyTiles(mainDropX, mainDropY, draggedTile.id);
            let snapAdj={dx:0, dy:0, groupId:null};
            if(nearMain.length>0){
              const closest=nearMain[0];
              snapAdj.dx = closest.snapX - mainDropX;
              snapAdj.dy = (SYLLABOARD_MODE ? 0 : (closest.snapY - mainDropY));
              snapAdj.groupId = closest.tile.groupId || closest.tile.id;
            }

            tiles = tiles.map(t=>{
              const inGroup=draggedGroup.some(gt=>gt.id===t.id);
              if(!inGroup) return t;
              const before=draggedGroup.find(gt=>gt.id===draggedTile.id);
              const offX=t.x - before.x;
              const offY=t.y - before.y;
              const newX=mainDropX + offX + snapAdj.dx;
              const newY=(SYLLABOARD_MODE ? SYLLA_ROW_Y : (mainDropY + offY + snapAdj.dy));
              return { ...t, x:newX, y:newY, groupId: snapAdj.groupId || null };
            });

            if(dragStartRowY!==null) recomputeGroupsAround(dragStartRowY);
            recomputeGroupsAround(SYLLABOARD_MODE ? SYLLA_ROW_Y : (mainDropY + snapAdj.dy));
          }
        }
      } else if(draggedTile.sourceType==='pane'){
        if(draggedGroup.length>0){
          const ids=new Set(draggedGroup.map(t=>t.id));
          const originY=draggedGroup[0].y;
          tiles=tiles.filter(t=>!ids.has(t.id));
          if(dragStartRowY!==null) recomputeGroupsAround(originY);
        }
      }

      finishDrop();

      function finishDrop(){
        draggedTile=null; draggedGroup=[]; dragStartRowY=null; clearDragVisual(); renderWordPane();
      }
    }

    // ====== DRAG VISUALS ======
    function updateDragVisual(){
      clearDragVisual();
      if(!draggedTile) return;
      const paneRect=document.getElementById('wordPane').getBoundingClientRect();

      if(draggedGroup.length>0){
        const dx=draggedTile.x - draggedTile.startX;
        const dy=draggedTile.y - draggedTile.startY;
        draggedGroup.forEach(t=>{
          const g=document.createElement('div');
          g.className=`tile ${t.color} dragging`;
          g.textContent=t.text;
          g.style.fontSize=getFontSize(t.text);
          const gx = t.x + dx + paneRect.left;
          const gy = (SYLLABOARD_MODE ? SYLLA_ROW_Y + paneRect.top : (t.y + dy + paneRect.top));
          g.style.transform=`translate3d(${Math.round(gx)}px, ${Math.round(gy)}px, 0)`;
          g.dataset.dragging='true';
          document.body.appendChild(g);
        });
      } else {
        const g=document.createElement('div');
        g.className=`tile ${draggedTile.color} dragging`;
        g.textContent=draggedTile.text;
        g.style.fontSize=getFontSize(draggedTile.text);
        const gx = draggedTile.x - dragOffset.x;
        const gy = (SYLLABOARD_MODE ? (document.getElementById('wordPane').getBoundingClientRect().top + SYLLA_ROW_Y) : (draggedTile.y - dragOffset.y));
        g.style.transform=`translate3d(${Math.round(gx)}px, ${Math.round(gy)}px, 0)`;
        g.dataset.dragging='true';
        document.body.appendChild(g);
      }
      // do not call renderWordPane() here to keep ghosts smooth
    }
    function clearDragVisual(){ document.querySelectorAll('[data-dragging="true"]').forEach(el=>el.remove()); }

    // ====== HELPERS ======
    function isVowelYInScope(){
      const lvl=parseInt(document.getElementById('lessonSelect').value,10);
      if(lvl<6) return false; const L=B_LEVELS[6]; return !!(L && L.yellow && L.yellow.includes('y'));
    }

    // ====== BOOT ======
    setupDrawers();
    document.getElementById('lessonSelect').addEventListener('change', renderTray);
    document.getElementById('resetButton').addEventListener('click', ()=>{
      tiles=[]; draggedTile=null; draggedGroup=[]; dragStartRowY=null; clearDragVisual(); renderWordPane();
    });
    document.getElementById('toggleSyllaboard').addEventListener('click', ()=>{
      SYLLABOARD_MODE=!SYLLABOARD_MODE;
      document.getElementById('toggleSyllaboard').textContent = `Syllaboard: ${SYLLABOARD_MODE?'On':'Off'}`;
      if(SYLLABOARD_MODE){
        // snap any existing tiles to the board row
        tiles = tiles.map(t=>({...t, y: SYLLA_ROW_Y}));
        recomputeGroupsAround(SYLLA_ROW_Y);
      }
      renderWordPane();
    });

    renderTray();
    renderWordPane();
  </script>
</body>
</html>
