<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>Barton Reading Tile Board</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap"
    rel="stylesheet"
  />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Lexend', sans-serif; overflow: hidden; touch-action: none; }
    #app { display: flex; flex-direction: column; height: 100vh; background-color: #f3f4f6; }
    #wordPane { flex: 1; background-color: white; border-bottom: 4px solid #1f2937; padding: 20px; overflow: auto; position: relative; }
    #wordPane .hint { color: #9ca3af; text-align: center; margin-top: 80px; font-size: 18px; }
    #tileTray { background-color: #e5e7eb; border-top: 2px solid #9ca3af; overflow-y: auto; max-height: 45vh; }
    .tile { width: 60px; height: 60px; border: 2px solid #374151; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: center; font-weight: bold; user-select: none; box-shadow: 0 2px 4px rgba(0,0,0,0.2); touch-action: none; flex-shrink: 0; }
    .tile:active { cursor: grabbing; }
    .tile.blue { background-color: #60a5fa; }
    .tile.yellow { background-color: #fbbf24; }
    .tile.red { background-color: #f87171; }
    .tile.green { background-color: #4ade80; }
    .tile.orange { background-color: #fb923c; }
    .tile.purple { background-color: #a78bfa; }
    .tile.dragging { opacity: 0.9; position: fixed; z-index: 1000; pointer-events: none; }
    .alphabet-section { border-bottom: 2px solid #9ca3af; padding: 12px; }
    .lesson-selector-bar { display: flex; justify-content: center; align-items: center; gap: 10px; padding: 8px; background-color: #d1d5db; border-radius: 4px; margin-bottom: 12px; }
    .lesson-selector-bar label { font-weight: bold; }
    .lesson-selector-bar select { font-family: 'Lexend', sans-serif; font-size: 16px; padding: 4px; }
    .tile-row { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; }
    .drawer { border-bottom: 1px solid #9ca3af; }
    .drawer-header { width: 100%; background-color: #d1d5db; padding: 8px 16px; font-weight: bold; font-size: 18px; display: flex; align-items: center; justify-content: space-between; cursor: pointer; border: none; text-align: left; }
    .drawer-header:hover { background-color: #9ca3af; }
    .drawer-content { background-color: #f3f4f6; padding: 8px; display: none; }
    .drawer-content.open { display: flex; flex-wrap: wrap; gap: 4px; }
    .word-pane-tile { position: absolute; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="app">
    <div id="wordPane">
      <div class="hint">Drag tiles here to build words. Tap to hear the sound.</div>
    </div>

    <div id="tileTray">
      <div class="alphabet-section">
        <div class="lesson-selector-bar">
          <label for="lessonSelect">Select Level:</label>
          <select id="lessonSelect">
            <option value="2">Book 2: Consonants & Short Vowels</option>
            <option value="3">Book 3: Closed & Unit Syllables</option>
            <option value="4">Book 4: Vowel Teams</option>
            <option value="5">Book 5: Prefixes & Suffixes</option>
            <option value="6">Book 6: Silent-E</option>
            <option value="7">Book 7: Vowel-R</option>
            <option value="8">Book 8: Advanced Vowel Teams</option>
            <option value="9">Book 9: Foreign Influences</option>
            <option value="10">Book 10: Greek & Latin</option>
          </select>
        </div>
        <div class="tile-row" id="lessonTiles"></div>
      </div>

      <div class="drawer" id="drawer-units">
        <button class="drawer-header" data-drawer="wordUnits">
          <span>Glued Sounds & Units (Red)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="wordUnits"></div>
      </div>

      <div class="drawer" id="drawer-suffixes">
        <button class="drawer-header" data-drawer="affixes">
          <span>Suffixes (Green)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="affixes"></div>
      </div>

      <div class="drawer" id="drawer-prefixes">
        <button class="drawer-header" data-drawer="prefixes">
          <span>Prefixes & VCE Units (Orange)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="prefixes"></div>
      </div>

      <div class="drawer" id="drawer-roots">
        <button class="drawer-header" data-drawer="latin">
          <span>Latin & Greek Roots (Purple)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="latin"></div>
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const TILE_SIZE = 60;
    const SNAP_DISTANCE = 10;

    // Tap vs drag thresholds
    const DRAG_START_PX = 8;      // move > 8px => drag
    const TAP_MAX_TIME_MS = 250;  // up to 250ms => tap
    const TAP_MAX_MOVE_PX = 6;    // <6px movement => tap

    // Minimal grapheme=>"sound" strings to drive speechSynthesis.
    // Replace these values with short audio files if you want true phonemes (recommended for instruction).
    const PHONEME_MAP = {
      // Short vowels
      a: "ă", e: "ĕ", i: "ĭ", o: "ŏ", u: "ŭ",
      // Common digraphs & units
      ch: "ch", sh: "sh", th: "th", wh: "hw", ck: "k",
      ph: "f", tch: "ch", dge: "j",
      // R-controlled & teams (approximations)
      ar: "ar", or: "or", er: "ər", ir: "ər", ur: "ər", ear: "eer",
      ai: "ā", ay: "ā", ee: "ē", ea: "ē", oa: "ō", oe: "ō", ue: "o͞o", ew: "o͞o", ow: "ō",
      oi: "oi", oy: "oi", au: "aw", aw: "aw", oo: "o͝o", ou: "ow", igh: "ī",
      // Foreign clusters
      ps: "s", rh: "r", mn: "n", wr: "r", kn: "n", gh: "g", gn: "n", que: "k", gu: "gw", gue: "g",
      // Single consonants (student-friendly approximations)
      b: "b", c: "k", d: "d", f: "f", g: "g", h: "h", j: "j", k: "k", l: "l", m: "m", n: "n",
      p: "p", qu: "kw", r: "r", s: "s", t: "t", v: "v", w: "w", x: "ks", y: "y", z: "z",
      y_vowel: "ĭ" // when you need vowel y, call with key 'y_vowel'
    };

    // Barton-style level sets
    const B_LEVELS = {
      2: { blue: ["b","c","d","f","g","h","j","k","l","m","n","p","qu","r","s","t","v","w","x","y","z","ch","ck","sh","th","wh"], yellow: ["a","e","i","o","u"] },
      3: { red: ["all","ang","ing","ong","ung","ank","ink","onk","unk","oll","old","olt","ost","ild","ind"] },
      4: { yellow: ["ai","ay","ee","oa","oe","ue","ew","ow"] },
      5: { green: ["s","es","ed","ing","er","est","ist","y","en","ish","ity","able","tion","sion"], orange: ["dis","in","un","non","mis","sub","re","pre","inter","mid","over","up"] },
      6: { blue: ["ph"], yellow: ["y"], red: ["ture"], green: ["ible","ble","cle","dle","fle","gle","kle","ple","tle","zle"], orange: ["ate","ite","ine","ice","ace","age"] },
      7: { yellow: ["ar","or","er","ir","ur","ear"], green: ["ary","ery","ory"] },
      8: { yellow: ["ie","oi","oy","ey","au","aw","oo","ou","ow","ea","igh","augh","eigh","ei","eu","tu"] },
      9: { blue: ["ps","rh","mn","wr","kn","gh","gn","que","gu","gue"], yellow: ["eau","our"], orange: ["age"] },
      10:{ purple: ["astro","auto","bio","chron","geo","graph","hydro","phon","tele","demo","fac","form","fort","fract","ject","jud","mal","mater","mit","mort","multi","pater","port","rupt","scrib","script","sect","sec","sent","spect","struct"] }
    };

    // ====== STATE ======
    let blueTiles = [], yellowTiles = [], redTiles = [], greenTiles = [], orangeTiles = [], purpleTiles = [];
    let tiles = [];                 // tiles currently on the pane
    let draggedTile = null;         // ephemeral drag meta
    let draggedGroup = [];          // members moving together
    let dragOffset = { x: 0, y: 0 };
    let gesture = null;             // tracks tap vs drag decisions

    // ====== UTIL ======
    function getFontSize(text) {
      if (text.length <= 2) return '24px';
      if (text.length === 3) return '20px';
      if (text.length === 4) return '16px';
      if (text.length === 5) return '14px';
      return '12px';
    }

    function getUniqueSorted(arr) {
      return [...new Set(arr)].sort((a, b) => (a.length === b.length ? a.localeCompare(b) : a.length - b.length));
    }

    function within(px, threshold) { return Math.abs(px) <= threshold; }

    // ====== AUDIO (placeholder: speech synthesis) ======
    function playPhoneme(grapheme, opts = {}) {
      // Allow forcing vowel-y vs consonant-y
      const key = (grapheme === 'y' && opts.vowelY) ? 'y_vowel' : grapheme;
      const sound = PHONEME_MAP[key];
      if (!sound) return;

      if ('speechSynthesis' in window) {
        const u = new SpeechSynthesisUtterance(sound);
        u.lang = 'en-US';
        u.rate = 0.8;   // a touch slower helps articulation
        u.pitch = 1.0;
        window.speechSynthesis.cancel(); // stop any queued
        window.speechSynthesis.speak(u);
      }
      // If you add real audio: new Audio('data:audio/wav;base64,...').play();
    }

    // ====== DOM BUILDERS ======
    function createTile(text, color, source) {
      const tile = document.createElement('div');
      tile.className = `tile ${color}`;
      tile.textContent = text;
      tile.style.fontSize = getFontSize(text);
      tile.dataset.text = text;
      tile.dataset.color = color;
      tile.dataset.source = source;

      // Unified pointer start -> resolves tap vs drag later
      tile.addEventListener('mousedown', (e) => onPointerStart(e, text, color, source));
      tile.addEventListener('touchstart', (e) => onPointerStart(e, text, color, source), { passive: false });

      return tile;
    }

function renderTray() {
  const selectedLevel = parseInt(document.getElementById('lessonSelect').value, 10);

  // collect sets for this level (up through selected)
  blueTiles = [];
  yellowTiles = [];
  redTiles = [];
  greenTiles = [];
  orangeTiles = [];
  purpleTiles = [];

  for (let i = 2; i <= selectedLevel; i++) {
    const L = B_LEVELS[i];
    if (!L) continue;
    if (L.blue)   blueTiles.push(...L.blue);
    if (L.yellow) yellowTiles.push(...L.yellow);
    if (L.red)    redTiles.push(...L.red);
    if (L.green)  greenTiles.push(...L.green);
    if (L.orange) orangeTiles.push(...L.orange);
    if (L.purple) purpleTiles.push(...L.purple);
  }

  // unique + sort for stability
  blueTiles   = getUniqueSorted(blueTiles);
  yellowTiles = getUniqueSorted(yellowTiles);
  redTiles    = getUniqueSorted(redTiles);
  greenTiles  = getUniqueSorted(greenTiles);
  orangeTiles = getUniqueSorted(orangeTiles);
  purpleTiles = getUniqueSorted(purpleTiles);

  // clear all containers
  const lessonTilesEl = document.getElementById('lessonTiles');
  const wordUnitsEl   = document.getElementById('wordUnits');
  const affixesEl     = document.getElementById('affixes');
  const prefixesEl    = document.getElementById('prefixes');
  const latinEl       = document.getElementById('latin');
  lessonTilesEl.innerHTML = '';
  wordUnitsEl.innerHTML   = '';
  affixesEl.innerHTML     = '';
  prefixesEl.innerHTML    = '';
  latinEl.innerHTML       = '';

// ----- alphabet row (A→Z with 'qu' in the 'q' slot; no standalone 'q') -----
const combinedBW  = [...blueTiles, ...yellowTiles];
const singlesSet  = new Set(combinedBW.filter(t => t.length === 1)); // a..z
const hasQU       = combinedBW.includes('qu');

// remove 'qu' from non-alphabet graphemes so it doesn't show twice
const othersByLen = getUniqueSorted(
  combinedBW.filter(t => t.length > 1 && t !== 'qu')
);

const ALPHABET = Array.from({ length: 26 }, (_, i) => String.fromCharCode(97 + i));
const orderedSingles = [];
for (const ch of ALPHABET) {
  if (ch === 'q') {
    if (hasQU) orderedSingles.push('qu'); // place 'qu' where q belongs
    continue; // never show a standalone 'q'
  }
  if (singlesSet.has(ch)) orderedSingles.push(ch);
}

const alphaRow = document.createElement('div');
alphaRow.className = 'tile-row';
orderedSingles.forEach(txt => {
  const color = yellowTiles.includes(txt) ? 'yellow' : 'blue';
  alphaRow.appendChild(createTile(txt, color, 'tray'));
});

// ----- remaining blue/yellow graphemes (digraphs, vowel teams, etc.) -----
const graphemeRow = document.createElement('div');
graphemeRow.className = 'tile-row';
othersByLen.forEach(txt => {
  const color = yellowTiles.includes(txt) ? 'yellow' : 'blue';
  graphemeRow.appendChild(createTile(txt, color, 'tray'));
});

lessonTilesEl.appendChild(alphaRow);
lessonTilesEl.appendChild(graphemeRow);


  // ----- drawers (unchanged behavior) -----
  const drawers = {
    units:    { elem: document.getElementById('drawer-units'),    tiles: redTiles,    color: 'red',    container: wordUnitsEl },
    suffixes: { elem: document.getElementById('drawer-suffixes'), tiles: greenTiles,  color: 'green',  container: affixesEl },
    prefixes: { elem: document.getElementById('drawer-prefixes'), tiles: orangeTiles, color: 'orange', container: prefixesEl },
    roots:    { elem: document.getElementById('drawer-roots'),    tiles: purpleTiles, color: 'purple', container: latinEl }
  };

  for (const key in drawers) {
    const d = drawers[key];
    if (d.tiles.length > 0) {
      d.elem.classList.remove('hidden');
      d.tiles.forEach(text => d.container.appendChild(createTile(text, d.color, 'tray')));
    } else {
      d.elem.classList.add('hidden');
      d.container.classList.remove('open');
      const arrow = d.elem.querySelector('.arrow');
      if (arrow) arrow.textContent = '▼';
    }
  }
}


    function renderWordPane() {
      const wordPane = document.getElementById('wordPane');
      const hint = wordPane.querySelector('.hint');

      wordPane.querySelectorAll('.word-pane-tile').forEach(el => el.remove());
      hint.style.display = tiles.length > 0 ? 'none' : 'block';

      tiles.forEach(tile => {
        // Prevent ghost duplicates while dragging as a group
        if (draggedGroup.find(t => t.id === tile.id)) return;

        const tileEl = document.createElement('div');
        tileEl.className = `tile ${tile.color} word-pane-tile`;
        tileEl.textContent = tile.text;
        tileEl.style.fontSize = getFontSize(tile.text);
        tileEl.style.left = tile.x + 'px';
        tileEl.style.top = tile.y + 'px';
        tileEl.dataset.id = tile.id;

        tileEl.addEventListener('mousedown', (e) => onPointerStart(e, tile.text, tile.color, tile.id));
        tileEl.addEventListener('touchstart', (e) => onPointerStart(e, tile.text, tile.color, tile.id), { passive: false });

        wordPane.appendChild(tileEl);
      });
    }

    // ====== LAYOUT / SNAP ======
    function findNearbyTiles(x, y, excludeId) {
      const nearby = [];
      tiles.forEach(tile => {
        if (tile.id === excludeId) return;
        const sameRow = Math.abs(tile.y - y) < TILE_SIZE / 2;

        if (sameRow) {
          // Snap to RIGHT edge of a neighbor (we become right-adjacent)
          if (Math.abs((tile.x + TILE_SIZE) - x) < SNAP_DISTANCE) {
            nearby.push({ tile, edge: 'right', snapX: tile.x + TILE_SIZE, snapY: tile.y });
          }
          // Snap to LEFT edge of a neighbor (we become left-adjacent)
          if (Math.abs(tile.x - (x + TILE_SIZE)) < SNAP_DISTANCE) {
            nearby.push({ tile, edge: 'left', snapX: tile.x - TILE_SIZE, snapY: tile.y });
          }
        }
      });
      // Heuristic: prefer the closest horizontally
      nearby.sort((a, b) => Math.abs(a.snapX - x) - Math.abs(b.snapX - x));
      return nearby;
    }

    // ====== POINTER HANDLERS (tap vs drag) ======
    function onPointerStart(e, text, color, source) {
      e.preventDefault();
      e.stopPropagation();

      const point = e.touches ? e.touches[0] : e;
      const targetRect = e.currentTarget.getBoundingClientRect();
      const startX = point.clientX;
      const startY = point.clientY;
      const tStart = performance.now();

      gesture = {
        startX, startY, tStart,
        moved: false,
        lastX: startX, lastY: startY,
        source, text, color,
        // capture for tap detection
        onMove: null, onEnd: null,
      };

      // INIT drag meta only when we confirm it's a drag (not immediately).
      // This is the key change that stops "pane clicks deleting neighbors."
      gesture.onMove = (ev) => {
        const p = ev.touches ? ev.touches[0] : ev;
        const dx = p.clientX - gesture.startX;
        const dy = p.clientY - gesture.startY;
        gesture.lastX = p.clientX;
        gesture.lastY = p.clientY;

        if (!gesture.moved && (Math.abs(dx) > DRAG_START_PX || Math.abs(dy) > DRAG_START_PX)) {
          gesture.moved = true;
          beginDrag(gesture, targetRect);
        }
        if (gesture.moved) {
          handleMove(ev);
        }
      };

      gesture.onEnd = (ev) => {
        const p = ev.changedTouches ? ev.changedTouches[0] : ev;
        const dt = performance.now() - gesture.tStart;
        const totalMove = Math.hypot(p.clientX - gesture.startX, p.clientY - gesture.startY);

        if (!gesture.moved && dt <= TAP_MAX_TIME_MS && totalMove <= TAP_MAX_MOVE_PX) {
          // Treat as TAP: play phoneme, do nothing to layout.
          // If 'y' in yellow collection, prefer vowel-y approximation
          playPhoneme(text, { vowelY: (text === 'y' && isVowelYInScope()) });
          cleanupPointerListeners();
          gesture = null;
          return;
        }

        // Otherwise, complete drag
        handleEnd(ev);
        cleanupPointerListeners();
        gesture = null;
      };

      document.addEventListener('mousemove', gesture.onMove, { passive: false });
      document.addEventListener('mouseup', gesture.onEnd, { passive: false });
      document.addEventListener('touchmove', gesture.onMove, { passive: false });
      document.addEventListener('touchend', gesture.onEnd, { passive: false });
    }

    function cleanupPointerListeners() {
      if (!gesture) return;
      document.removeEventListener('mousemove', gesture.onMove);
      document.removeEventListener('mouseup', gesture.onEnd);
      document.removeEventListener('touchmove', gesture.onMove);
      document.removeEventListener('touchend', gesture.onEnd);
    }

    function beginDrag(g, targetRect) {
      const startX = g.startX;
      const startY = g.startY;
      const source = g.source;

      if (source === 'tray') {
        draggedTile = {
          text: g.text, color: g.color,
          x: startX, y: startY,
          sourceType: 'tray',
          startX, startY
        };
        draggedGroup = [];
      } else {
        const paneTile = tiles.find(t => t.id === source);
        if (!paneTile) return; // stale
        draggedTile = {
          ...paneTile,
          x: startX, y: startY,
          sourceType: 'pane',
          startX, startY
        };
        // start with just this tile; group may expand as we move laterally
        draggedGroup = [paneTile];
      }

      // set offset so the ghost stays under the pointer
      dragOffset = {
        x: startX - targetRect.left,
        y: startY - targetRect.top
      };
      updateDragVisual();
    }

    function handleMove(e) {
      if (!draggedTile) return;
      e.preventDefault();

      const p = e.touches ? e.touches[0] : e;
      const newX = p.clientX;
      const newY = p.clientY;

      draggedTile.x = newX;
      draggedTile.y = newY;

      // Build/adjust group for pane tiles when moving horizontally
      if (draggedTile.sourceType === 'pane') {
        const dx = newX - draggedTile.startX;
        const dy = newY - draggedTile.startY;

        if (Math.abs(dx) > 12 || Math.abs(dy) > 12) {
          const currentTile = tiles.find(t => t.id === draggedTile.id);
          if (currentTile) {
            const sameLine = tiles
              .filter(t => Math.abs(t.y - currentTile.y) < TILE_SIZE / 2)
              .sort((a, b) => a.x - b.x);

            const idx = sameLine.findIndex(t => t.id === currentTile.id);
            const leftNeighbor  = sameLine[idx - 1];
            const rightNeighbor = sameLine[idx + 1];

            const touchingLeft  = !!leftNeighbor  && Math.abs(leftNeighbor.x + TILE_SIZE - currentTile.x) < 6;
            const touchingRight = !!rightNeighbor && Math.abs(currentTile.x + TILE_SIZE - rightNeighbor.x) < 6;

            if (dx < 0 && touchingLeft) {
              draggedGroup = sameLine.slice(0, idx + 1); // drag left chunk
            } else if (dx > 0 && touchingRight) {
              draggedGroup = sameLine.slice(idx);        // drag right chunk
            } else {
              draggedGroup = [currentTile];
            }
          }
        }
      }

      updateDragVisual();
    }

    function handleEnd(e) {
      if (!draggedTile) return;
      e.preventDefault();

      const p = e.changedTouches ? e.changedTouches[0] : e;
      const wordPane = document.getElementById('wordPane');
      const paneRect = wordPane.getBoundingClientRect();

      const insidePane = (
        p.clientX >= paneRect.left && p.clientX <= paneRect.right &&
        p.clientY >= paneRect.top  && p.clientY <= paneRect.bottom
      );

      if (insidePane) {
        const dropX = p.clientX - paneRect.left - dragOffset.x;
        const dropY = p.clientY - paneRect.top  - dragOffset.y;

        if (draggedTile.sourceType === 'tray') {
          const nearby = findNearbyTiles(dropX, dropY, null);
          let finalX = dropX, finalY = dropY, groupId = null;
          if (nearby.length > 0) {
            const closest = nearby[0];
            finalX = closest.snapX; finalY = closest.snapY;
            groupId = closest.tile.groupId || closest.tile.id;
          }
          const newTile = {
            id: Date.now() + Math.random(),
            text: draggedTile.text,
            color: draggedTile.color,
            x: finalX, y: finalY,
            groupId
          };
          tiles.push(newTile);
        } else {
          if (draggedGroup.length > 0) {
            // Compute main's drop
            const main = draggedGroup.find(gt => gt.id === draggedTile.id);
            const mainDropX = p.clientX - paneRect.left - (draggedTile.startX - main.x);
            const mainDropY = p.clientY - paneRect.top  - (draggedTile.startY - main.y);

            // Try snapping main
            const nearMain = findNearbyTiles(mainDropX, mainDropY, draggedTile.id);
            let snapAdj = { dx: 0, dy: 0, groupId: null };
            if (nearMain.length > 0) {
              const closest = nearMain[0];
              snapAdj.dx = closest.snapX - mainDropX;
              snapAdj.dy = closest.snapY - mainDropY;
              snapAdj.groupId = closest.tile.groupId || closest.tile.id;
            }

            tiles = tiles.map(t => {
              const inGroup = draggedGroup.some(gt => gt.id === t.id);
              if (!inGroup) return t;

              const mainBefore = draggedGroup.find(gt => gt.id === draggedTile.id);
              const offX = t.x - mainBefore.x;
              const offY = t.y - mainBefore.y;

              const newX = mainDropX + offX + snapAdj.dx;
              const newY = mainDropY + offY + snapAdj.dy;

              return { ...t, x: newX, y: newY, groupId: snapAdj.groupId };
            });
          }
        }
      } else if (draggedTile.sourceType === 'pane') {
        // Dropped outside pane: delete dragged group cleanly
        if (draggedGroup.length > 0) {
          const ids = new Set(draggedGroup.map(t => t.id));
          tiles = tiles.filter(t => !ids.has(t.id));
        }
      }

      draggedTile = null;
      draggedGroup = [];
      clearDragVisual();
      renderWordPane();
    }

    // ====== DRAG VISUALS ======
    function updateDragVisual() {
      clearDragVisual();
      if (!draggedTile) return;

      const wordPane = document.getElementById('wordPane');
      const paneRect = wordPane.getBoundingClientRect();

      if (draggedGroup.length > 0) {
        const dx = draggedTile.x - draggedTile.startX;
        const dy = draggedTile.y - draggedTile.startY;

        draggedGroup.forEach(tile => {
          const ghost = document.createElement('div');
          ghost.className = `tile ${tile.color} dragging`;
          ghost.textContent = tile.text;
          ghost.style.fontSize = getFontSize(tile.text);
          ghost.style.left = (tile.x + dx + paneRect.left) + 'px';
          ghost.style.top  = (tile.y + dy + paneRect.top)  + 'px';
          ghost.dataset.dragging = 'true';
          document.body.appendChild(ghost);
        });
      } else {
        const ghost = document.createElement('div');
        ghost.className = `tile ${draggedTile.color} dragging`;
        ghost.textContent = draggedTile.text;
        ghost.style.fontSize = getFontSize(draggedTile.text);
        ghost.style.left = (draggedTile.x - dragOffset.x) + 'px';
        ghost.style.top  = (draggedTile.y - dragOffset.y) + 'px';
        ghost.dataset.dragging = 'true';
        document.body.appendChild(ghost);
      }

      renderWordPane();
    }

    function clearDragVisual() {
      document.querySelectorAll('[data-dragging="true"]').forEach(el => el.remove());
    }

    // ====== HELPERS ======
    function isVowelYInScope() {
      // crude heuristic: if yellow 'y' is currently offered in lesson, treat taps of 'y' as vowel-y
      const selectedLevel = parseInt(document.getElementById('lessonSelect').value, 10);
      if (selectedLevel < 6) return false;
      const lvl6 = B_LEVELS[6];
      return !!(lvl6 && lvl6.yellow && lvl6.yellow.includes('y'));
    }

    // ====== BOOT ======
    document.querySelectorAll('.drawer-header').forEach(header => {
      header.addEventListener('click', (e) => {
        const drawer = e.currentTarget.closest('.drawer');
        const content = drawer.querySelector('.drawer-content');
        const arrow = e.currentTarget.querySelector('.arrow');
        if (content.classList.contains('open')) {
          content.classList.remove('open'); arrow.textContent = '▼';
        } else {
          content.classList.add('open'); arrow.textContent = '▲';
        }
      });
    });

    document.getElementById('lessonSelect').addEventListener('change', renderTray);

    renderTray();
    renderWordPane();
  </script>
</body>
</html>
