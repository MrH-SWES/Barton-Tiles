<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
  />
  <title>Barton Reading Tile Board</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap"
    rel="stylesheet"
  />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* Mobile-friendly touch handling */
    body { font-family: 'Lexend', sans-serif; overflow: hidden; touch-action: manipulation; }
    #tileTray { background-color: #e5e7eb; border-top: 2px solid #9ca3af; overflow-y: auto; max-height: 45vh; touch-action: pan-y; }
    #wordPane, .tile { touch-action: none; } /* drag area never scrolls */

    #app { display: flex; flex-direction: column; height: 100vh; background-color: #f3f4f6; }
    #wordPane { flex: 1; background-color: white; border-bottom: 4px solid #1f2937; padding: 20px; overflow: auto; position: relative; }
    #wordPane .hint { color: #9ca3af; text-align: center; margin-top: 80px; font-size: 18px; }

    .tile { width: 60px; height: 60px; border: 2px solid #374151; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: center; font-weight: bold; user-select: none; box-shadow: 0 2px 4px rgba(0,0,0,0.2); flex-shrink: 0; }
    .tile:active { cursor: grabbing; }
    .tile.blue { background-color: #60a5fa; }
    .tile.yellow { background-color: #fbbf24; }
    .tile.red { background-color: #f87171; }
    .tile.green { background-color: #4ade80; }
    .tile.orange { background-color: #fb923c; }
    .tile.purple { background-color: #a78bfa; }

    /* Drag ghosts use transforms for smooth GPU movement */
    .tile.dragging {
      opacity: 0.9;
      position: fixed;
      z-index: 1000;
      pointer-events: none;
      will-change: transform;
    }

    .alphabet-section { border-bottom: 2px solid #9ca3af; padding: 12px; }
    .lesson-selector-bar { display: flex; justify-content: center; align-items: center; gap: 10px; padding: 8px; background-color: #d1d5db; border-radius: 4px; margin-bottom: 12px; }
    .lesson-selector-bar label { font-weight: bold; }
    .lesson-selector-bar select { font-family: 'Lexend', sans-serif; font-size: 16px; padding: 4px; }

    .tile-row { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; }
    .drawer { border-bottom: 1px solid #9ca3af; }
    .drawer-header { width: 100%; background-color: #d1d5db; padding: 8px 16px; font-weight: bold; font-size: 18px; display: flex; align-items: center; justify-content: space-between; cursor: pointer; border: none; text-align: left; }
    .drawer-header:hover { background-color: #9ca3af; }
    .drawer-content { background-color: #f3f4f6; padding: 8px; display: none; }
    .drawer-content.open { display: flex; flex-wrap: wrap; gap: 4px; }

    .word-pane-tile { position: absolute; }
    .hidden { display: none !important; }

    /* Reset button styling */
    #resetButton {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #dc2626;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 14px;
      font-weight: bold;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="wordPane">
      <button id="resetButton">Reset</button>
      <div class="hint">Drag tiles here to build words. Tap to hear.</div>
    </div>

    <div id="tileTray">
      <div class="alphabet-section">
        <div class="lesson-selector-bar">
          <label for="lessonSelect">Select Level:</label>
          <select id="lessonSelect">
            <option value="2">Book 2: Consonants & Short Vowels</option>
            <option value="3">Book 3: Closed & Unit Syllables</option>
            <option value="4">Book 4: Vowel Teams</option>
            <option value="5">Book 5: Prefixes & Suffixes</option>
            <option value="6">Book 6: Silent-E</option>
            <option value="7">Book 7: Vowel-R</option>
            <option value="8">Book 8: Advanced Vowel Teams</option>
            <option value="9">Book 9: Foreign Influences</option>
            <option value="10">Book 10: Greek & Latin</option>
          </select>
        </div>
        <div class="tile-row" id="lessonTiles"></div>
      </div>

      <div class="drawer" id="drawer-units">
        <button class="drawer-header" data-drawer="wordUnits">
          <span>Glued Sounds & Units (Red)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="wordUnits"></div>
      </div>

      <div class="drawer" id="drawer-suffixes">
        <button class="drawer-header" data-drawer="affixes">
          <span>Suffixes (Green)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="affixes"></div>
      </div>

      <div class="drawer" id="drawer-prefixes">
        <button class="drawer-header" data-drawer="prefixes">
          <span>Prefixes & VCE Units (Orange)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="prefixes"></div>
      </div>

      <div class="drawer" id="drawer-roots">
        <button class="drawer-header" data-drawer="latin">
          <span>Latin & Greek Roots (Purple)</span><span class="arrow">▼</span>
        </button>
        <div class="drawer-content" id="latin"></div>
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
const TILE_SIZE = 60;

// Touch-friendly snapping
const SNAP_DISTANCE = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) ? 16 : 10;

// Seam insertion capture width
const SEAM_CAPTURE = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) ? 22 : 14;

// require some vertical overlap between tiles for a snap to be valid
const MIN_VERTICAL_OVERLAP = Math.floor(TILE_SIZE * 0.25);

// Drag thresholds
function dragThresholdFor(e) { return (e && e.pointerType === 'touch') ? 12 : 6; }

// Tap detection
const TAP_MAX_TIME_MS = 250;
const TAP_MAX_MOVE_PX = 6;

    // ====== AUDIO: files preferred for single grapheme taps (tray) ======
    // Host your own audio files (same origin) if you have them; missing keys fall back to TTS.
    const AUDIO_MAP = {
      // example mappings; add the ones you actually host
      "a": "/audio/a.mp3", "e": "/audio/e.mp3", "i": "/audio/i.mp3", "o": "/audio/o.mp3", "u": "/audio/u.mp3",
      "b": "/audio/b.mp3", "c": "/audio/c.mp3", "d": "/audio/d.mp3", "f": "/audio/f.mp3", "g": "/audio/g.mp3",
      "h": "/audio/h.mp3", "j": "/audio/j.mp3", "k": "/audio/k.mp3", "l": "/audio/l.mp3", "m": "/audio/m.mp3",
      "n": "/audio/n.mp3", "p": "/audio/p.mp3", "qu": "/audio/qu.mp3", "r": "/audio/r.mp3", "s": "/audio/s.mp3",
      "t": "/audio/t.mp3", "v": "/audio/v.mp3", "w": "/audio/w.mp3", "x": "/audio/x.mp3", "y": "/audio/y_consonant.mp3",
      "z": "/audio/z.mp3",
      "ch": "/audio/ch.mp3", "sh": "/audio/sh.mp3", "th": "/audio/th.mp3", "wh": "/audio/wh.mp3",
      "ar": "/audio/ar.mp3", "or": "/audio/or.mp3", "er": "/audio/er.mp3", "ir": "/audio/ir.mp3", "ur": "/audio/ur.mp3",
      "ai": "/audio/ai.mp3", "ay": "/audio/ay.mp3", "ee": "/audio/ee.mp3", "oa": "/audio/oa.mp3", "igh": "/audio/igh.mp3",
      "y_vowel": "/audio/y_vowel.mp3"
    };
    const _audioCache = new Map();
    function getAudio(graphemeKey) {
      const url = AUDIO_MAP[graphemeKey];
      if (!url) return null;
      if (_audioCache.has(url)) return _audioCache.get(url);
      const el = new Audio(url);
      el.preload = "auto";
      _audioCache.set(url, el);
      return el;
    }
    window.addEventListener("load", () => {
      ["a","e","i","o","u","ch","sh","th","qu"].forEach(k => { const el = getAudio(k); if (el) { try { el.load(); } catch(_){} } });
    });

    // TTS fallback map for single graphemes
    const PHONEME_TTS = {
      a: "ă", e: "ĕ", i: "ĭ", o: "ŏ", u: "ŭ",
      ch: "ch", sh: "sh", th: "th", wh: "hw", ck: "k",
      ph: "f", tch: "ch", dge: "j",
      ar: "ar", or: "or", er: "ər", ir: "ər", ur: "ər", ear: "eer",
      ai: "ā", ay: "ā", ee: "ē", ea: "ē", oa: "ō", oe: "ō", ue: "o͞o", ew: "o͞o", ow: "ō",
      oi: "oi", oy: "oi", au: "aw", aw: "aw", oo: "o͝o", ou: "ow", igh: "ī",
      ps: "s", rh: "r", mn: "n", wr: "r", kn: "n", gh: "g", gn: "n", que: "k", gu: "gw", gue: "g",
      b: "b", c: "k", d: "d", f: "f", g: "g", h: "h", j: "j", k: "k", l: "l", m: "m", n: "n",
      p: "p", qu: "kw", r: "r", s: "s", t: "t", v: "v", w: "w", x: "ks", y: "y", z: "z",
      y_vowel: "ĭ"
    };

    function speakTTS(text) {
      if (!text) return;
      if ("speechSynthesis" in window) {
        try {
          const u = new SpeechSynthesisUtterance(text);
          u.lang = "en-US";
          u.rate = 0.9;
          u.pitch = 1.0;
          window.speechSynthesis.cancel();
          window.speechSynthesis.speak(u);
        } catch(_) {}
      }
    }

    function playPhoneme(grapheme, opts = {}) {
      const key = (grapheme === 'y' && opts.vowelY) ? 'y_vowel' : grapheme;

      const audio = getAudio(key);
      if (audio) {
        try {
          _audioCache.forEach(a => { if (!a.paused && a !== audio) { try { a.pause(); a.currentTime = 0; } catch(_){} }});
          audio.currentTime = 0;
          audio.play().catch(() => speakTTS(PHONEME_TTS[key] || key));
          return;
        } catch(_) {}
      }
      const t = PHONEME_TTS[key];
      speakTTS(t || key);
    }

    // ====== SYLLABLE/WORD TAPS: speak the full assembled text ======
    function speakUnitForTileId(tileId) {
      const t = tiles.find(x => x.id === tileId);
      if (!t) return;
      const chain = getGroupChain(t);     // contiguous by geometry
      const text = chain.map(x => x.text).join('');
      speakTTS(text);                      // let TTS realize syllable/word
    }

    // ====== LEVEL DATA ======
    const B_LEVELS = {
      2: { blue: ["b","c","d","f","g","h","j","k","l","m","n","p","qu","r","s","t","v","w","x","y","z","ch","ck","sh","th","wh"], yellow: ["a","e","i","o","u"] },
      3: { red: ["all","ang","ing","ong","ung","ank","ink","onk","unk","oll","old","olt","ost","ild","ind"] },
      4: { yellow: ["ai","ay","ee","oa","oe","ue","ew","ow"] },
      5: { green: ["s","es","ed","ing","er","est","ist","y","en","ish","ity","able","tion","sion"], orange: ["dis","in","un","non","mis","sub","re","pre","inter","mid","over","up"] },
      6: { blue: ["ph"], yellow: ["y"], red: ["ture"], green: ["ible","ble","cle","dle","fle","gle","kle","ple","tle","zle"], orange: ["ate","ite","ine","ice","ace","age"] },
      7: { yellow: ["ar","or","er","ir","ur","ear"], green: ["ary","ery","ory"] },
      8: { yellow: ["ie","oi","oy","ey","au","aw","oo","ou","ow","ea","igh","augh","eigh","ei","eu","tu"] },
      9: { blue: ["ps","rh","mn","wr","kn","gh","gn","que","gu","gue"], yellow: ["eau","our"], orange: ["age"] },
      10:{ purple: ["astro","auto","bio","chron","geo","graph","hydro","phon","tele","demo","fac","form","fort","fract","ject","jud","mal","mater","mit","mort","multi","pater","port","rupt","scrib","script","sect","sec","sent","spect","struct"] }
    };

    // ====== STATE ======
    let blueTiles = [], yellowTiles = [], redTiles = [], greenTiles = [], orangeTiles = [], purpleTiles = [];
    let tiles = [];                 // tiles on the pane
    let draggedTile = null;         // ephemeral drag meta
    let draggedGroup = [];          // members moving together
    let dragOffset = { x: 0, y: 0 };
    let gesture = null;             // tap vs drag
    let dragStartRowY = null;       // row y at drag start

    // ====== UTIL ======
    function getFontSize(text) {
      if (text.length <= 2) return '24px';
      if (text.length === 3) return '20px';
      if (text.length === 4) return '16px';
      if (text.length === 5) return '14px';
      return '12px';
    }

    function getUniqueSorted(arr) {
      return [...new Set(arr)].sort((a, b) => (a.length === b.length ? a.localeCompare(b) : a.length - b.length));
    }

    function sameRowY(y1, y2) { return Math.abs(y1 - y2) < TILE_SIZE / 2; }
    function areFlush(a, b, tol = 2) { return Math.abs(a.x + TILE_SIZE - b.x) <= tol; }

    // Recompute groupIds for the row around a given y
    function recomputeGroupsAround(rowY) {
      const row = tiles.filter(t => sameRowY(t.y, rowY)).sort((a,b) => a.x - b.x);
      let i = 0;
      while (i < row.length) {
        let j = i + 1;
        while (j < row.length && areFlush(row[j-1], row[j])) j++;
        const seg = row.slice(i, j);
        if (seg.length === 1) seg[0].groupId = null;
        else {
          const gid = seg[0].groupId || seg[0].id;
          for (const t of seg) t.groupId = gid;
        }
        i = j;
      }
    }

    // Build the current contiguous chain by geometry
    function getGroupChain(main) {
      const row = tiles
        .filter(t => Math.abs(t.y - main.y) < TILE_SIZE / 2)
        .sort((a, b) => a.x - b.x);

      const idx = row.findIndex(t => t.id === main.id);
      if (idx === -1) return [main];

      // expand left/right while edges are flush
      let L = idx;
      while (L - 1 >= 0 && Math.abs(row[L - 1].x + TILE_SIZE - row[L].x) <= 2) L--;
      let R = idx;
      while (R + 1 < row.length && Math.abs(row[R].x + TILE_SIZE - row[R + 1].x) <= 2) R++;

      return row.slice(L, R + 1);
    }

    // ====== SEAM INSERTION ======
    function findSeamNear(dropX, dropY) {
      const row = tiles
        .filter(t => Math.abs(t.y - dropY) < TILE_SIZE / 2)
        .sort((a,b)=>a.x - b.x);

      for (let i = 0; i < row.length - 1; i++) {
        const L = row[i], R = row[i+1];
        if (!areFlush(L, R)) continue;
        const seamX = L.x + TILE_SIZE;
        if (Math.abs(dropX - seamX) <= SEAM_CAPTURE) {
          return { left: L, right: R, seamX, rowY: L.y };
        }
      }
      return null;
    }

    function insertAtSeam(newTileData, seam) {
      const { right, rowY } = seam;

      // shift right side of the seam by one tile width
      const rightSide = tiles
        .filter(t => Math.abs(t.y - rowY) < TILE_SIZE / 2 && t.x >= right.x)
        .sort((a,b)=>a.x - b.x);

      rightSide.forEach(t => { t.x += TILE_SIZE; });

      // place the new tile into the gap
      const newTile = {
        id: Date.now() + Math.random(),
        text: newTileData.text,
        color: newTileData.color,
        x: right.x - TILE_SIZE,
        y: rowY,
        groupId: null
      };
      tiles.push(newTile);

      // regroup the row so it becomes a single chain
      recomputeGroupsAround(rowY);
    }

    // ====== DOM BUILDERS ======
    function createTile(text, color, source) {
      const tile = document.createElement('div');
      tile.className = `tile ${color}`;
      tile.textContent = text;
      tile.style.fontSize = getFontSize(text);
      tile.dataset.text = text;
      tile.dataset.color = color;
      tile.dataset.source = source;

      // Pointer Events: one set of listeners for all inputs
      tile.addEventListener('pointerdown', (e) => onPointerStart(e, text, color, source));

      return tile;
    }

    function renderTray() {
      const selectedLevel = parseInt(document.getElementById('lessonSelect').value, 10);

      blueTiles = []; yellowTiles = []; redTiles = []; greenTiles = []; orangeTiles = []; purpleTiles = [];
      for (let i = 2; i <= selectedLevel; i++) {
        const L = B_LEVELS[i];
        if (!L) continue;
        if (L.blue)   blueTiles.push(...L.blue);
        if (L.yellow) yellowTiles.push(...L.yellow);
        if (L.red)    redTiles.push(...L.red);
        if (L.green)  greenTiles.push(...L.green);
        if (L.orange) orangeTiles.push(...L.orange);
        if (L.purple) purpleTiles.push(...L.purple);
      }

      blueTiles   = getUniqueSorted(blueTiles);
      yellowTiles = getUniqueSorted(yellowTiles);
      redTiles    = getUniqueSorted(redTiles);
      greenTiles  = getUniqueSorted(greenTiles);
      orangeTiles = getUniqueSorted(orangeTiles);
      purpleTiles = getUniqueSorted(purpleTiles);

      const lessonTilesEl = document.getElementById('lessonTiles');
      const wordUnitsEl   = document.getElementById('wordUnits');
      const affixesEl     = document.getElementById('affixes');
      const prefixesEl    = document.getElementById('prefixes');
      const latinEl       = document.getElementById('latin');
      lessonTilesEl.innerHTML = '';
      wordUnitsEl.innerHTML   = '';
      affixesEl.innerHTML     = '';
      prefixesEl.innerHTML    = '';
      latinEl.innerHTML       = '';

      // Alphabet row (A→Z with 'qu' occupying the q slot; no standalone 'q')
      const combinedBW  = [...blueTiles, ...yellowTiles];
      const singlesSet  = new Set(combinedBW.filter(t => t.length === 1)); // a..z
      const hasQU       = combinedBW.includes('qu');
      const othersByLen = getUniqueSorted(combinedBW.filter(t => t.length > 1 && t !== 'qu'));

      const ALPHABET = Array.from({ length: 26 }, (_, i) => String.fromCharCode(97 + i));
      const orderedSingles = [];
      for (const ch of ALPHABET) {
        if (ch === 'q') { if (hasQU) orderedSingles.push('qu'); continue; }
        if (singlesSet.has(ch)) orderedSingles.push(ch);
      }

      const alphaRow = document.createElement('div');
      alphaRow.className = 'tile-row';
      orderedSingles.forEach(txt => {
        const color = yellowTiles.includes(txt) ? 'yellow' : 'blue';
        alphaRow.appendChild(createTile(txt, color, 'tray'));
      });

      const graphemeRow = document.createElement('div');
      graphemeRow.className = 'tile-row';
      othersByLen.forEach(txt => {
        const color = yellowTiles.includes(txt) ? 'yellow' : 'blue';
        graphemeRow.appendChild(createTile(txt, color, 'tray'));
      });

      lessonTilesEl.appendChild(alphaRow);
      lessonTilesEl.appendChild(graphemeRow);

      const drawers = {
        units:    { elem: document.getElementById('drawer-units'),    tiles: redTiles,    color: 'red',    container: wordUnitsEl },
        suffixes: { elem: document.getElementById('drawer-suffixes'), tiles: greenTiles,  color: 'green',  container: affixesEl },
        prefixes: { elem: document.getElementById('drawer-prefixes'), tiles: orangeTiles, color: 'orange', container: prefixesEl },
        roots:    { elem: document.getElementById('drawer-roots'),    tiles: purpleTiles, color: 'purple', container: latinEl }
      };

      for (const key in drawers) {
        const d = drawers[key];
        if (d.tiles.length > 0) {
          d.elem.classList.remove('hidden');
          d.tiles.forEach(text => d.container.appendChild(createTile(text, d.color, 'tray')));
        } else {
          d.elem.classList.add('hidden');
          d.container.classList.remove('open');
          const arrow = d.elem.querySelector('.arrow');
          if (arrow) arrow.textContent = '▼';
        }
      }
    }

    function renderWordPane() {
      const wordPane = document.getElementById('wordPane');
      const hint = wordPane.querySelector('.hint');

      wordPane.querySelectorAll('.word-pane-tile').forEach(el => el.remove());
      hint.style.display = tiles.length > 0 ? 'none' : 'block';

      tiles.forEach(tile => {
        if (draggedGroup.find(t => t.id === tile.id)) return;

        const tileEl = document.createElement('div');
        tileEl.className = `tile ${tile.color} word-pane-tile`;
        tileEl.textContent = tile.text;
        tileEl.style.fontSize = getFontSize(tile.text);
        tileEl.style.left = tile.x + 'px';
        tileEl.style.top = tile.y + 'px';
        tileEl.dataset.id = tile.id;

        tileEl.addEventListener('pointerdown', (e) => onPointerStart(e, tile.text, tile.color, tile.id));
        wordPane.appendChild(tileEl);
      });
    }

    // ====== LAYOUT / SNAP ======
 function findNearbyTiles(dropX, dropY, excludeId) {
  // The dragged tile’s tentative bbox at drop location
  const dragLeft   = dropX;
  const dragRight  = dropX + TILE_SIZE;
  const dragTop    = dropY;
  const dragBottom = dropY + TILE_SIZE;

  const candidates = [];

  for (const tile of tiles) {
    if (tile.id === excludeId) continue;

    const nbrLeft   = tile.x;
    const nbrRight  = tile.x + TILE_SIZE;
    const nbrTop    = tile.y;
    const nbrBottom = tile.y + TILE_SIZE;

    // vertical overlap amount
    const overlapY = Math.min(dragBottom, nbrBottom) - Math.max(dragTop, nbrTop);
    if (overlapY <= 0 || overlapY < MIN_VERTICAL_OVERLAP) continue;

    // If ANY of our LEFT edge is near the neighbor’s RIGHT edge -> snap to the RIGHT side of that tile
    const leftEdgeGap = Math.abs(nbrRight - dragLeft);
    if (leftEdgeGap <= SNAP_DISTANCE) {
      candidates.push({
        tile,
        edge: 'right',
        // snap our left edge to neighbor’s right edge, and align vertically to neighbor’s y
        snapX: nbrRight,
        snapY: tile.y
      });
    }

    // If ANY of our RIGHT edge is near the neighbor’s LEFT edge -> snap to the LEFT side of that tile
    const rightEdgeGap = Math.abs(nbrLeft - dragRight);
    if (rightEdgeGap <= SNAP_DISTANCE) {
      candidates.push({
        tile,
        edge: 'left',
        snapX: nbrLeft - TILE_SIZE,
        snapY: tile.y
      });
    }
  }

  // Prefer the closest edge snap horizontally; tie-break by smallest vertical offset to the neighbor
  candidates.sort((a, b) => {
    const axGap = Math.abs(a.edge === 'right' ? (a.tile.x + TILE_SIZE) - dragLeft : a.tile.x - dragRight);
    const bxGap = Math.abs(b.edge === 'right' ? (b.tile.x + TILE_SIZE) - dragLeft : b.tile.x - dragRight);
    if (axGap !== bxGap) return axGap - bxGap;
    const ayGap = Math.abs(a.snapY - dropY);
    const byGap = Math.abs(b.snapY - dropY);
    return ayGap - byGap;
  });

  return candidates;
}


    // ====== POINTER HANDLERS ======
    function onPointerStart(e, text, color, source) {
      if (e.isPrimary === false) return;
      e.preventDefault();
      e.stopPropagation();

      // Pointer capture keeps the stream alive; we do NOT re-render at drag start.
      if (e.currentTarget.setPointerCapture) {
        try { e.currentTarget.setPointerCapture(e.pointerId); } catch (_) {}
      }

      const targetRect = e.currentTarget.getBoundingClientRect();
      const startX = e.clientX;
      const startY = e.clientY;
      const tStart = performance.now();

      gesture = {
        startX, startY, tStart,
        moved: false,
        lastX: startX, lastY: startY,
        source, text, color,
        pointerType: e.pointerType,
        onMove: null, onEnd: null,
      };

      gesture.onMove = (ev) => {
        const dx = ev.clientX - gesture.startX;
        const dy = ev.clientY - gesture.startY;
        gesture.lastX = ev.clientX;
        gesture.lastY = ev.clientY;

        const threshold = dragThresholdFor(ev);
        if (!gesture.moved && (Math.abs(dx) > threshold || Math.abs(dy) > threshold)) {
          gesture.moved = true;
          beginDrag(gesture, targetRect, dx, dy);
        }
        if (gesture.moved) handleMove(ev);
      };

      gesture.onEnd = (ev) => {
        const dt = performance.now() - gesture.tStart;
        const totalMove = Math.hypot(ev.clientX - gesture.startX, ev.clientY - gesture.startY);

        if (!gesture.moved && dt <= TAP_MAX_TIME_MS && totalMove <= TAP_MAX_MOVE_PX) {
          if (gesture.source !== 'tray') {
            // Tap on pane tile: speak whole contiguous unit/syllable
            speakUnitForTileId(gesture.source);
          } else {
            // Tap in tray: play single grapheme sound
            playPhoneme(text, { vowelY: (text === 'y' && isVowelYInScope()) });
          }
          cleanupPointerListeners();
          gesture = null;
          return;
        }

        handleEnd(ev);
        cleanupPointerListeners();
        gesture = null;
      };

      document.addEventListener('pointermove', gesture.onMove, { passive: false });
      document.addEventListener('pointerup',   gesture.onEnd,  { passive: false });
      document.addEventListener('pointercancel', gesture.onEnd, { passive: false });
    }

    function cleanupPointerListeners() {
      if (!gesture) return;
      document.removeEventListener('pointermove', gesture.onMove);
      document.removeEventListener('pointerup',   gesture.onEnd);
      document.removeEventListener('pointercancel', gesture.onEnd);
    }

    function beginDrag(g, targetRect, dx = 0, dy = 0) {
      const startX = g.startX;
      const startY = g.startY;
      const source = g.source;

      if (source === 'tray') {
        draggedTile = { text: g.text, color: g.color, x: startX, y: startY, sourceType: 'tray', startX, startY };
        draggedGroup = [];
        dragStartRowY = null;
      } else {
        const paneTile = tiles.find(t => t.id === source);
        if (!paneTile) return;

        // current contiguous chain containing the grabbed tile
        const chain = getGroupChain(paneTile);
        const idx = chain.findIndex(t => t.id === paneTile.id);

        // decide split: horizontal => side including grabbed; vertical => single
        const horizontal = Math.abs(dx) >= Math.abs(dy); // 45° rule
        if (!horizontal) {
          draggedGroup = [paneTile]; // vertical pull-out
        } else if (dx < 0) {
          draggedGroup = chain.slice(0, idx + 1); // left side including grabbed
        } else {
          draggedGroup = chain.slice(idx);        // right side including grabbed
        }

        draggedTile = { ...paneTile, x: startX, y: startY, sourceType: 'pane', startX, startY };
        dragStartRowY = paneTile.y;
      }

      dragOffset = { x: startX - targetRect.left, y: startY - targetRect.top };
      updateDragVisual(); // paint ghosts immediately
    }

    function handleMove(e) {
      if (!draggedTile) return;
      e.preventDefault();

      draggedTile.x = e.clientX;
      draggedTile.y = e.clientY;

      updateDragVisual(); // paint ghosts immediately
    }

    function handleEnd(e) {
      if (!draggedTile) return;
      e.preventDefault();

      const wordPane = document.getElementById('wordPane');
      const paneRect = wordPane.getBoundingClientRect();

      const insidePane = (
        e.clientX >= paneRect.left && e.clientX <= paneRect.right &&
        e.clientY >= paneRect.top  && e.clientY <= paneRect.bottom
      );

      if (insidePane) {
        const dropX = e.clientX - paneRect.left - dragOffset.x;
        const dropY = e.clientY - paneRect.top  - dragOffset.y;

        if (draggedTile.sourceType === 'tray') {
          // Try seam insertion first
          const seam = findSeamNear(dropX, dropY);
          if (seam) {
            insertAtSeam({ text: draggedTile.text, color: draggedTile.color }, seam);
            draggedTile = null;
            draggedGroup = [];
            dragStartRowY = null;
            clearDragVisual();
            renderWordPane();
            return;
          }

          // fallback to normal snap
          const nearby = findNearbyTiles(dropX, dropY, null);
          let finalX = dropX, finalY = dropY, groupId = null;
          if (nearby.length > 0) {
            const closest = nearby[0];
            finalX = closest.snapX; finalY = closest.snapY;
            groupId = closest.tile.groupId || closest.tile.id;
          }
          const newTile = { id: Date.now() + Math.random(), text: draggedTile.text, color: draggedTile.color, x: finalX, y: finalY, groupId };
          tiles.push(newTile);
          recomputeGroupsAround(finalY);
        } else {
          if (draggedGroup.length > 0) {
            // If we're moving a single tile, allow seam insertion.
            if (draggedGroup.length === 1) {
              const seam = findSeamNear(dropX, dropY);
              if (seam) {
                const only = draggedGroup[0];
                const originY = only.y;
                tiles = tiles.filter(t => t.id !== only.id);
                if (dragStartRowY !== null) recomputeGroupsAround(originY);

                insertAtSeam({ text: only.text, color: only.color }, seam);

                draggedTile = null;
                draggedGroup = [];
                dragStartRowY = null;
                clearDragVisual();
                renderWordPane();
                return;
              }
            }

            // Otherwise: move the whole selected subgroup with snap-to-unit
            const main = draggedGroup.find(gt => gt.id === draggedTile.id);
            const mainDropX = e.clientX - paneRect.left - (draggedTile.startX - main.x);
            const mainDropY = e.clientY - paneRect.top  - (draggedTile.startY - main.y);

            const nearMain = findNearbyTiles(mainDropX, mainDropY, draggedTile.id);
            let snapAdj = { dx: 0, dy: 0, groupId: null };
            if (nearMain.length > 0) {
              const closest = nearMain[0];
              snapAdj.dx = closest.snapX - mainDropX;
              snapAdj.dy = closest.snapY - mainDropY;
              snapAdj.groupId = closest.tile.groupId || closest.tile.id;
            }

            tiles = tiles.map(t => {
              const inGroup = draggedGroup.some(gt => gt.id === t.id);
              if (!inGroup) return t;

              const mainBefore = draggedGroup.find(gt => gt.id === draggedTile.id);
              const offX = t.x - mainBefore.x;
              const offY = t.y - mainBefore.y;

              const newX = mainDropX + offX + snapAdj.dx;
              const newY = mainDropY + offY + snapAdj.dy;

              return { ...t, x: newX, y: newY, groupId: snapAdj.groupId || null };
            });

            if (dragStartRowY !== null) recomputeGroupsAround(dragStartRowY);
            recomputeGroupsAround(mainDropY + snapAdj.dy);
          }
        }
      } else if (draggedTile.sourceType === 'pane') {
        // Dropped outside pane: delete dragged group and regroup origin row
        if (draggedGroup.length > 0) {
          const ids = new Set(draggedGroup.map(t => t.id));
          const originY = draggedGroup[0].y;
          tiles = tiles.filter(t => !ids.has(t.id));
          if (dragStartRowY !== null) recomputeGroupsAround(originY);
        }
      }

      draggedTile = null;
      draggedGroup = [];
      dragStartRowY = null;
      clearDragVisual();
      renderWordPane();
    }

    // ====== DRAG VISUALS ======
    function updateDragVisual() {
      clearDragVisual();
      if (!draggedTile) return;

      const wordPane = document.getElementById('wordPane');
      const paneRect = wordPane.getBoundingClientRect();

      if (draggedGroup.length > 0) {
        const dx = draggedTile.x - draggedTile.startX;
        const dy = draggedTile.y - draggedTile.startY;

        draggedGroup.forEach(tile => {
          const ghost = document.createElement('div');
          ghost.className = `tile ${tile.color} dragging`;
          ghost.textContent = tile.text;
          ghost.style.fontSize = getFontSize(tile.text);

          // anchor and move with transform
          ghost.style.left = '0px';
          ghost.style.top  = '0px';
          const gx = tile.x + dx + paneRect.left;
          const gy = tile.y + dy + paneRect.top;
          ghost.style.transform = `translate3d(${Math.round(gx)}px, ${Math.round(gy)}px, 0)`;

          ghost.dataset.dragging = 'true';
          document.body.appendChild(ghost);
        });
      } else {
        const ghost = document.createElement('div');
        ghost.className = `tile ${draggedTile.color} dragging`;
        ghost.textContent = draggedTile.text;
        ghost.style.fontSize = getFontSize(draggedTile.text);

        ghost.style.left = '0px';
        ghost.style.top  = '0px';
        const gx = draggedTile.x - dragOffset.x;
        const gy = draggedTile.y - dragOffset.y;
        ghost.style.transform = `translate3d(${Math.round(gx)}px, ${Math.round(gy)}px, 0)`;

        ghost.dataset.dragging = 'true';
        document.body.appendChild(ghost);
      }
    }

    function clearDragVisual() {
      document.querySelectorAll('[data-dragging="true"]').forEach(el => el.remove());
    }

    // ====== HELPERS ======
    function isVowelYInScope() {
      const selectedLevel = parseInt(document.getElementById('lessonSelect').value, 10);
      if (selectedLevel < 6) return false;
      const lvl6 = B_LEVELS[6];
      return !!(lvl6 && lvl6.yellow && lvl6.yellow.includes('y'));
    }

    // ====== BOOT ======
    document.querySelectorAll('.drawer-header').forEach(header => {
      header.addEventListener('click', (e) => {
        const drawer = e.currentTarget.closest('.drawer');
        const content = drawer.querySelector('.drawer-content');
        const arrow = e.currentTarget.querySelector('.arrow');
        if (content.classList.contains('open')) {
          content.classList.remove('open'); arrow.textContent = '▼';
        } else {
          content.classList.add('open'); arrow.textContent = '▲';
        }
      });
    });

    document.getElementById('lessonSelect').addEventListener('change', renderTray);

    // Reset button: instant clear, no confirmation
    document.getElementById('resetButton').addEventListener('click', () => {
      tiles = [];
      draggedTile = null;
      draggedGroup = [];
      dragStartRowY = null;
      clearDragVisual();
      renderWordPane();
    });

    renderTray();
    renderWordPane();
  </script>
</body>
</html>
