<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Barton Reading Tile Board</title>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Lexend', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #333; /* Darker bg for the app to stand out */
        }
        
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 800px; /* Max-width for better desktop layout */
            margin: 0 auto; /* Center the app */
            background-color: #f3f4f6;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        /* --- MODIFIED: Word Pane is now Lined Paper --- */
        #wordPane {
            flex: 1;
            background-color: #fefdfa; /* Creamy paper color */
            border-bottom: 4px solid #1f2937;
            padding: 20px 20px 20px 40px; /* Added left padding for margin line */
            overflow: auto;
            position: relative;
        }

        /* --- NEW: The paper lines --- */
        .paper-line {
            height: 100px; /* This is our snap target height */
            border-bottom: 2px solid #dbe9f5;
            position: relative;
        }
        
        /* --- NEW: The red margin line --- */
        .paper-line:first-child::before {
            content: '';
            position: absolute;
            left: -20px;
            top: -20px; /* Extends into padding */
            bottom: -20px; /* Extends into next line */
            width: 2px;
            background-color: #f89a9a;
            z-index: 1;
        }

        #tileTray {
            background-color: #e5e7eb;
            border-top: 2px solid #9ca3af;
            overflow-y: auto;
            max-height: 45vh;
        }
        
        /* --- MODIFIED: "Cooler" 3D Tiles --- */
        .tile {
            width: 60px;
            height: 60px;
            border: 1px solid rgba(0,0,0,0.2);
            border-bottom: 4px solid rgba(0,0,0,0.3); /* "Bottom edge" */
            border-radius: 6px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
            box-shadow: 0 3px 5px rgba(0,0,0,0.15), 0 1px 2px rgba(0,0,0,0.1);
            touch-action: none;
            flex-shrink: 0;
            color: #374151;
            text-shadow: 0 1px 1px rgba(255,255,255,0.5);
            /* --- NEW: Transitions for animations --- */
            transition: transform 0.15s ease-out, opacity 0.15s ease-out, box-shadow 0.15s ease-out;
        }

        .tile.blue { 
            background-color: #60a5fa;
            background-image: linear-gradient(to bottom, #7bb0fb, #60a5fa 50%);
        }
        .tile.yellow { 
            background-color: #fbbf24;
            background-image: linear-gradient(to bottom, #fcd34d, #fbbf24 50%);
        }
        .tile.red { 
            background-color: #f87171;
            background-image: linear-gradient(to bottom, #f98a8a, #f87171 50%);
        }
        .tile.green { 
            background-color: #4ade80;
            background-image: linear-gradient(to bottom, #6be69a, #4ade80 50%);
        }
        .tile.orange { 
            background-color: #fb923c;
            background-image: linear-gradient(to bottom, #fca55f, #fb923c 50%);
        }
        .tile.purple { 
            background-color: #a78bfa;
            background-image: linear-gradient(to bottom, #b8a4fc, #a78bfa 50%);
        }
        
        /* --- MODIFIED: Dragging style for "lift" effect --- */
        .tile.dragging {
            opacity: 0.9;
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            transform: scale(1.1); /* "Lift" effect */
            box-shadow: 0 10px 20px rgba(0,0,0,0.3), 0 3px 6px rgba(0,0,0,0.2);
        }

        /* --- NEW: Fade-out animation on delete --- */
        .tile.dragging.fading-out {
            opacity: 0 !important;
            transform: scale(0.8) !important;
            transition: opacity 0.2s ease-in, transform 0.2s ease-in;
        }

        /* --- NEW: Snap animation --- */
        @keyframes snap {
            0% { transform: scale(1.1); }
            70% { transform: scale(0.98); }
            100% { transform: scale(1.0); }
        }
        .snap-animation {
            animation: snap 0.2s ease-out;
        }

        .alphabet-section {
            border-bottom: 2px solid #9ca3af;
            padding: 12px;
        }
        
        .lesson-selector-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background-color: #d1d5db;
            border-radius: 4px;
            margin-bottom: 12px;
        }
        
        .lesson-selector-bar label {
            font-weight: bold;
        }

        .lesson-selector-bar select {
            font-family: 'Lexend', sans-serif;
            font-size: 16px;
            padding: 4px;
        }

        .tile-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
        }
        
        .drawer {
            border-bottom: 1px solid #9ca3af;
        }
        
        .drawer-header {
            width: 100%;
            background-color: #d1d5db;
            padding: 8px 16px;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            border: none;
            text-align: left;
        }
        
        .drawer-header:hover {
            background-color: #9ca3af;
        }
        
        .drawer-content {
            background-color: #f3f4f6;
            padding: 8px;
            display: none;
        }
        
        .drawer-content.open {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        /* --- MODIFIED: Word pane tiles now have a higher z-index --- */
        .word-pane-tile {
            position: absolute;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="wordPane">
            <div class="paper-line"></div>
            <div class="paper-line"></div>
            <div class="paper-line"></div>
            <div class="paper-line"></div>
        </div>
        
        <div id="tileTray">
            <div class="alphabet-section">
                
                <div class="lesson-selector-bar">
                    <label for="lessonSelect">Select Level:</label>
                    <select id="lessonSelect">
                        <option value="2">Book 2: Consonants & Short Vowels</option>
                        <option value="3">Book 3: Closed & Unit Syllables</option>
                        <option value="4">Book 4: Vowel Teams</option>
                        <option value="5">Book 5: Prefixes & Suffixes</option>
                        <option value="6">Book 6: Silent-E</option>
                        <option value="7">Book 7: Vowel-R</option>
                        <option value="8">Book 8: Advanced Vowel Teams</option>
                        <option value="9">Book 9: Foreign Influences</option>
                        <option value="10">Book 10: Greek & Latin</option>
                    </select>
                </div>
                
                <div class="tile-row" id="lessonTiles"></div>

            </div>
            
            <div class="drawer" id="drawer-units">
                <button class="drawer-header" data-drawer="wordUnits">
                    <span>Glued Sounds & Units (Red)</span>
                    <span class="arrow">▼</span>
                </button>
                <div class="drawer-content" id="wordUnits"></div>
            </div>
            
            <div class="drawer" id="drawer-suffixes">
                <button class="drawer-header" data-drawer="affixes">
                    <span>Suffixes (Green)</span>
                    <span class="arrow">▼</span>
                </button>
                <div class="drawer-content" id="affixes"></div>
            </div>
            
            <div class="drawer" id="drawer-prefixes">
                <button class="drawer-header" data-drawer="prefixes">
                    <span>Prefixes & VCE Units (Orange)</span>
                    <span class="arrow">▼</span>
                </button>
                <div class="drawer-content" id="prefixes"></div>
            </div>
            
            <div class="drawer" id="drawer-roots">
                <button class="drawer-header" data-drawer="latin">
                    <span>Latin & Greek Roots (Purple)</span>
                    <span class="arrow">▼</span>
                </button>
                <div class="drawer-content" id="latin"></div>
            </div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 60;
        const SNAP_DISTANCE = 10;
        
        // --- NEW: Constants for line snapping ---
        const LINE_HEIGHT = 100; // Must match .paper-line height in CSS
        const PANE_PADDING_TOP = 20; // Must match #wordPane padding-top in CSS

        const B_LEVELS = {
            2: {
                blue: ["b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "qu", "r", "s", "t", "v", "w", "x", "y", "z", "ch", "ck", "sh", "th", "wh"],
                yellow: ["a", "e", "i", "o", "u"]
            },
            3: {
                red: ["all", "ang", "ing", "ong", "ung", "ank", "ink", "onk", "unk", "oll", "old", "olt", "ost", "ild", "ind"]
            },
            4: {
                yellow: ["ai", "ay", "ee", "oa", "oe", "ue", "ew", "ow"]
            },
            5: {
                green: ["s", "es", "ed", "ing", "er", "est", "ist", "y", "en", "ish", "ity", "able", "tion", "sion"],
                orange: ["dis", "in", "un", "non", "mis", "sub", "re", "pre", "inter", "mid", "over", "up"]
            },
            6: {
                blue: ["ph"],
                yellow: ["y"],
                red: ["ture"],
                green: ["ible", "ble", "cle", "dle", "fle", "gle", "kle", "ple", "tle", "zle"],
                orange: ["ate", "ite", "ine", "ice", "ace", "age"]
            },
            7: {
                yellow: ["ar", "or", "er", "ir", "ur", "ear"],
                green: ["ary", "ery", "ory"]
            },
            8: {
                yellow: ["ie", "oi", "oy", "ey", "au", "aw", "oo", "ou", "ow", "ea", "igh", "augh", "eigh", "ei", "eu", "tu"]
            },
            9: {
                blue: ["ps", "rh", "mn", "wr", "kn", "gh", "gn", "que", "gu", "gue"],
                yellow: ["eau", "our"],
                orange: ["age"]
            },
            10: {
                purple: [
                    "astro", "auto", "bio", "chron", "geo", "graph", "hydro", "phon", "tele", "demo",
                    "fac", "form", "fort", "fract", "ject", "jud", "mal", "mater", "mit", "mort",
                    "multi", "pater", "port", "rupt", "scrib", "script", "sect", "sec", "sent", "spect", "struct"
                ]
            }
        };

        let blueTiles = [];
        let yellowTiles = [];
        let redTiles = [];
        let greenTiles = [];
        let orangeTiles = [];
        let purpleTiles = [];
        
        let tiles = [];
        let draggedTile = null;
        let draggedGroup = [];
        let dragOffset = { x: 0, y: 0 };
        
        function getFontSize(text) {
            if (text.length <= 2) return '24px';
            if (text.length === 3) return '20px';
            if (text.length === 4) return '16px';
            if (text.length === 5) return '14px';
            return '12px';
        }
        
        function createTile(text, color, source) {
            const tile = document.createElement('div');
            tile.className = `tile ${color}`;
            tile.textContent = text;
            tile.style.fontSize = getFontSize(text);
            tile.dataset.text = text;
            tile.dataset.color = color;
            tile.dataset.source = source;
            
            tile.addEventListener('mousedown', (e) => handleTileStart(e, text, color, source));
            tile.addEventListener('touchstart', (e) => handleTileStart(e, text, color, source), { passive: false });
            
            return tile;
        }

        function getUniqueSorted(arr) {
            return [...new Set(arr)].sort((a, b) => {
                if (a.length === b.length) {
                    return a.localeCompare(b);
                }
                return a.length - b.length;
            });
        }
        
        function renderTray() {
            const selectedLevel = parseInt(document.getElementById('lessonSelect').value, 10);

            blueTiles = [];
            yellowTiles = [];
            redTiles = [];
            greenTiles = [];
            orangeTiles = [];
            purpleTiles = [];

            for (let i = 2; i <= selectedLevel; i++) {
                if (B_LEVELS[i]) {
                    if (B_LEVELS[i].blue) blueTiles.push(...B_LEVELS[i].blue);
                    if (B_LEVELS[i].yellow) yellowTiles.push(...B_LEVELS[i].yellow);
                    if (B_LEVELS[i].red) redTiles.push(...B_LEVELS[i].red);
                    if (B_LEVELS[i].green) greenTiles.push(...B_LEVELS[i].green);
                    if (B_LEVELS[i].orange) orangeTiles.push(...B_LEVELS[i].orange);
                    if (B_LEVELS[i].purple) purpleTiles.push(...B_LEVELS[i].purple);
                }
            }

            blueTiles = getUniqueSorted(blueTiles);
            yellowTiles = getUniqueSorted(yellowTiles);
            redTiles = getUniqueSorted(redTiles);
            greenTiles = getUniqueSorted(greenTiles);
            orangeTiles = getUniqueSorted(orangeTiles);
            purpleTiles = getUniqueSorted(purpleTiles);

            document.getElementById('lessonTiles').innerHTML = '';
            document.getElementById('wordUnits').innerHTML = '';
            document.getElementById('affixes').innerHTML = '';
            document.getElementById('prefixes').innerHTML = '';
            document.getElementById('latin').innerHTML = '';

            const lessonTilesContainer = document.getElementById('lessonTiles');
            blueTiles.forEach(text => lessonTilesContainer.appendChild(createTile(text, 'blue', 'tray')));
            yellowTiles.forEach(text => lessonTilesContainer.appendChild(createTile(text, 'yellow', 'tray')));

            const drawers = {
                units: { elem: document.getElementById('drawer-units'), tiles: redTiles, color: 'red', container: document.getElementById('wordUnits') },
                suffixes: { elem: document.getElementById('drawer-suffixes'), tiles: greenTiles, color: 'green', container: document.getElementById('affixes') },
                prefixes: { elem: document.getElementById('drawer-prefixes'), tiles: orangeTiles, color: 'orange', container: document.getElementById('prefixes') },
                roots: { elem: document.getElementById('drawer-roots'), tiles: purpleTiles, color: 'purple', container: document.getElementById('latin') }
            };

            for (const key in drawers) {
                const drawer = drawers[key];
                if (drawer.tiles.length > 0) {
                    drawer.elem.classList.remove('hidden');
                    drawer.tiles.forEach(text => drawer.container.appendChild(createTile(text, drawer.color, 'tray')));
                } else {
                    drawer.elem.classList.add('hidden');
                    drawer.container.classList.remove('open');
                    const arrow = drawer.elem.querySelector('.arrow');
                    if (arrow) arrow.textContent = '▼';
                }
            }
        }
        
        // --- MODIFIED: renderWordPane triggers snap animation ---
        function renderWordPane() {
            const wordPane = document.getElementById('wordPane');
            
            const existingTiles = wordPane.querySelectorAll('.word-pane-tile');
            existingTiles.forEach(tile => tile.remove());
            
            // Hint logic is removed
            
            tiles.forEach(tile => {
                if (draggedGroup.find(t => t.id === tile.id)) return;
                
                const tileEl = document.createElement('div');
                tileEl.className = `tile ${tile.color} word-pane-tile`;
                tileEl.textContent = tile.text;
                tileEl.style.fontSize = getFontSize(tile.text);
                tileEl.style.left = tile.x + 'px';
                tileEl.style.top = tile.y + 'px';
                tileEl.dataset.id = tile.id;

                // --- NEW: Add snap animation class if tile was just dropped ---
                if (tile.snapped) {
                    tileEl.classList.add('snap-animation');
                    delete tile.snapped; // Clean up the flag
                }
                
                tileEl.addEventListener('mousedown', (e) => handleTileStart(e, tile.text, tile.color, tile.id));
                tileEl.addEventListener('touchstart', (e) => handleTileStart(e, tile.text, tile.color, tile.id), { passive: false });
                
                wordPane.appendChild(tileEl);
            });
        }
        
        // --- MODIFIED: findNearbyTiles now only checks tiles on the same line ---
        function findNearbyTiles(x, y, excludeId) {
            const nearby = [];
            tiles.forEach(tile => {
                if (tile.id === excludeId) return;
                
                // Only check for tiles on the *exact same Y level*
                if (Math.abs(tile.y - y) < 10) { 
                    // Snap to right edge of existing tile
                    if (Math.abs((tile.x + TILE_SIZE) - x) < SNAP_DISTANCE) {
                        nearby.push({ tile, edge: 'right', snapX: tile.x + TILE_SIZE, snapY: tile.y });
                    }
                    // Snap to left edge of existing tile
                    if (Math.abs(tile.x - (x + TILE_SIZE)) < SNAP_DISTANCE) {
                        nearby.push({ tile, edge: 'left', snapX: tile.x - TILE_SIZE, snapY: tile.y });
                    }
                }
            });
            // Sort by distance to find the closest
            nearby.sort((a, b) => Math.abs(a.snapX - x) - Math.abs(b.snapX - x));
            return nearby;
        }
        
        function handleTileStart(e, text, color, source) {
            e.preventDefault();
            e.stopPropagation();
            
            const touch = e.touches ? e.touches[0] : e;
            const rect = e.target.getBoundingClientRect();

            if (source === 'tray') {
                draggedTile = {
                    text: text,
                    color: color,
                    x: touch.clientX,
                    y: touch.clientY,
                    sourceType: 'tray',
                    startX: touch.clientX,
                    startY: touch.clientY
                };
                draggedGroup = [];
            } else {
                const tile = tiles.find(t => t.id === source);
                draggedTile = {
                    ...tile,
                    x: touch.clientX,
                    y: touch.clientY,
                    sourceType: 'pane',
                    startX: touch.clientX,
                    startY: touch.clientY
                };
                draggedGroup = [tile]; 
            }
            
            dragOffset = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            
            updateDragVisual();
        }
        
        function handleMove(e) {
            if (!draggedTile) return;
            e.preventDefault();
            
            const touch = e.touches ? e.touches[0] : e;
            const newX = touch.clientX;
            const newY = touch.clientY;
            
            draggedTile.x = newX;
            draggedTile.y = newY;
            
            if (draggedTile.sourceType === 'pane') {
                const deltaX = newX - draggedTile.startX;
                const deltaY = newY - draggedTile.startY;
                const absDeltaX = Math.abs(deltaX);
                const absDeltaY = Math.abs(deltaY);
                
                if (absDeltaX > 10 || absDeltaY > 10) { // Smaller threshold for group drag
                    if (absDeltaX > absDeltaY) {
                        const currentTile = tiles.find(t => t.id === draggedTile.id);
                        const sameLine = tiles.filter(t => 
                            Math.abs(t.y - currentTile.y) < TILE_SIZE / 2
                        ).sort((a, b) => a.x - b.x);
                        
                        const currentIndex = sameLine.findIndex(t => t.id === draggedTile.id);
                        
                        const hasLeftNeighbor = currentIndex > 0 && 
                            Math.abs(sameLine[currentIndex - 1].x + TILE_SIZE - currentTile.x) < 10;
                        const hasRightNeighbor = currentIndex < sameLine.length - 1 && 
                            Math.abs(currentTile.x + TILE_SIZE - sameLine[currentIndex + 1].x) < 10;
                        
                        if (deltaX < 0 && hasLeftNeighbor) {
                            const group = sameLine.slice(0, currentIndex + 1);
                            draggedGroup = group;
                        } else if (deltaX > 0 && hasRightNeighbor) {
                            const group = sameLine.slice(currentIndex);
                            draggedGroup = group;
                        } else {
                            draggedGroup = [currentTile];
                        }
                    }
                }
            }
            
            updateDragVisual();
        }
        
        // --- MODIFIED: handleEnd now contains all snap logic ---
        function handleEnd(e) {
            if (!draggedTile) return;
            e.preventDefault();
            
            const touch = e.changedTouches ? e.changedTouches[0] : e;
            const wordPane = document.getElementById('wordPane');
            const paneRect = wordPane.getBoundingClientRect();
            
            // Check if dropped inside the word pane
            if (touch.clientX >= paneRect.left && 
                touch.clientX <= paneRect.right && 
                touch.clientY >= paneRect.top && 
                touch.clientY <= paneRect.bottom) {
                
                // --- NEW: Snap-to-Line Logic ---
                const dropX_raw = touch.clientX - paneRect.left - dragOffset.x;
                const dropY_raw = touch.clientY - paneRect.top - dragOffset.y;
                
                // Find the closest line index
                const snappedLineIndex = Math.max(0, Math.floor((dropY_raw + (LINE_HEIGHT / 2)) / LINE_HEIGHT));
                // Calculate the final Y position for the top of the tile
                const finalY = (snappedLineIndex * LINE_HEIGHT) + PANE_PADDING_TOP + (LINE_HEIGHT - TILE_SIZE - 10); // 10px from bottom
                
                let finalX = dropX_raw;
                let groupId = null;
                
                // Check for horizontal snaps on the *same line*
                const nearby = findNearbyTiles(finalX, finalY, draggedTile.id);
                if (nearby.length > 0) {
                    finalX = nearby[0].snapX; // Snap to the closest tile
                    groupId = nearby[0].tile.groupId || nearby[0].tile.id;
                }
                
                if (draggedTile.sourceType === 'tray') {
                    const newTile = {
                        id: Date.now() + Math.random(),
                        text: draggedTile.text,
                        color: draggedTile.color,
                        x: finalX,
                        y: finalY,
                        groupId: groupId,
                        snapped: true // --- NEW: Flag for animation ---
                    };
                    tiles.push(newTile);

                } else if (draggedGroup.length > 0) {
                    // This handles pane-to-pane drags (both single and group)
                    tiles = tiles.map(t => {
                        const inGroup = draggedGroup.find(gt => gt.id === t.id);
                        if (inGroup) {
                            // Find offset from the main dragged tile
                            const offsetX = t.x - draggedTile.x;
                            const newX = finalX + offsetX;
                            return { ...t, x: newX, y: finalY, groupId: groupId, snapped: true };
                        }
                        return t;
                    });
                }
            } else if (draggedTile.sourceType === 'pane') {
                // Dropped outside: filter out the dragged group
                if (draggedGroup.length > 0) {
                    tiles = tiles.filter(t => !draggedGroup.find(gt => gt.id === t.id));
                }
            }
            
            draggedTile = null;
            draggedGroup = [];
            clearDragVisual();
            renderWordPane();
        }
        
        function updateDragVisual() {
            clearDragVisual();
            
            if (!draggedTile) return;
            
            const wordPane = document.getElementById('wordPane');
            const paneRect = wordPane.getBoundingClientRect();
            
            if (draggedGroup.length > 0) {
                const deltaX = draggedTile.x - draggedTile.startX;
                const deltaY = draggedTile.y - draggedTile.startY;
                
                draggedGroup.forEach(tile => {
                    const tileEl = document.createElement('div');
                    tileEl.className = `tile ${tile.color} dragging`;
                    tileEl.textContent = tile.text;
                    tileEl.style.fontSize = getFontSize(tile.text);
                    tileEl.style.left = (tile.x + deltaX + paneRect.left) + 'px';
                    tileEl.style.top = (tile.y + deltaY + paneRect.top) + 'px';
                    tileEl.dataset.dragging = 'true';
                    document.body.appendChild(tileEl);
                });
            } else { 
                const tileEl = document.createElement('div');
                tileEl.className = `tile ${draggedTile.color} dragging`;
                tileEl.textContent = draggedTile.text;
                tileEl.style.fontSize = getFontSize(draggedTile.text);
                tileEl.style.left = (draggedTile.x - dragOffset.x) + 'px';
                tileEl.style.top = (draggedTile.y - dragOffset.y) + 'px';
                tileEl.dataset.dragging = 'true';
                document.body.appendChild(tileEl);
            }
            
            renderWordPane();
        }
        
        // --- MODIFIED: clearDragVisual now animates the deletion ---
        function clearDragVisual() {
            document.querySelectorAll('[data-dragging="true"]').forEach(el => {
                if (draggedTile === null) { // Only animate if it's a delete
                    el.classList.add('fading-out');
                    setTimeout(() => el.remove(), 200); // Remove after animation
                } else {
                    el.remove(); // Remove immediately if it's just a drop
                }
            });
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('touchend', handleEnd);
        
        document.querySelectorAll('.drawer-header').forEach(header => {
            header.addEventListener('click', (e) => {
                const drawer = e.currentTarget.closest('.drawer');
                const content = drawer.querySelector('.drawer-content');
                const arrow = e.currentTarget.querySelector('.arrow');
                
                if (content.classList.contains('open')) {
                    content.classList.remove('open');
                    arrow.textContent = '▼';
                } else {
                    content.classList.add('open');
                    arrow.textContent = '▲';
                }
            });
        });

        document.getElementById('lessonSelect').addEventListener('change', renderTray);
        
        renderTray();
        renderWordPane();
    </script>
</body>
</html>
