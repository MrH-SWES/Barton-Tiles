<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Barton Reading Tile Board</title>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Lexend', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #f3f4f6;
        }
        
        #wordPane {
            flex: 1;
            background-color: white;
            border-bottom: 4px solid #1f2937;
            padding: 20px;
            overflow: auto;
            position: relative;
        }
        
        #wordPane .hint {
            color: #9ca3af;
            text-align: center;
            margin-top: 80px;
            font-size: 18px;
        }
        
        #tileTray {
            background-color: #e5e7eb;
            border-top: 2px solid #9ca3af;
            overflow-y: auto;
            max-height: 45vh;
        }
        
        .tile {
            width: 60px;
            height: 60px;
            border: 2px solid #374151;
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            touch-action: none;
            flex-shrink: 0;
        }
        
        .tile.blue { background-color: #60a5fa; }
        .tile.yellow { background-color: #fbbf24; }
        .tile.red { background-color: #f87171; }
        .tile.green { background-color: #4ade80; }
        .tile.orange { background-color: #fb923c; }
        .tile.purple { background-color: #a78bfa; }
        
        .tile.dragging {
            opacity: 0.8;
            position: fixed;
            z-index: 1000;
            pointer-events: none;
        }
        
        .alphabet-section {
            border-bottom: 2px solid #9ca3af;
            padding: 12px;
        }
        
        .lesson-selector-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background-color: #d1d5db;
            border-radius: 4px;
            margin-bottom: 12px;
        }
        
        .lesson-selector-bar label {
            font-weight: bold;
        }

        .lesson-selector-bar select {
            font-family: 'Lexend', sans-serif;
            font-size: 16px;
            padding: 4px;
        }

        .tile-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
        }
        
        .drawer {
            border-bottom: 1px solid #9ca3af;
        }
        
        .drawer-header {
            width: 100%;
            background-color: #d1d5db;
            padding: 8px 16px;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            border: none;
            text-align: left;
        }
        
        .drawer-header:hover {
            background-color: #9ca3af;
        }
        
        .drawer-content {
            background-color: #f3f4f6;
            padding: 8px;
            display: none;
        }
        
        .drawer-content.open {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .word-pane-tile {
            position: absolute;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="wordPane">
            <div class="hint">Drag tiles here to build words</div>
        </div>
        
        <div id="tileTray">
            <div class="alphabet-section">
                
                <div class="lesson-selector-bar">
                    <label for="lessonSelect">Select Level:</label>
                    <select id="lessonSelect">
                        <option value="2">Book 2: Consonants & Short Vowels</option>
                        <option value="3">Book 3: Closed & Unit Syllables</option>
                        <option value="4">Book 4: Vowel Teams</option>
                        <option value="5">Book 5: Prefixes & Suffixes</option>
                        <option value="6">Book 6: Silent-E</option>
                        <option value="7">Book 7: Vowel-R</option>
                        <option value="8">Book 8: Advanced Vowel Teams</option>
                        <option value="9">Book 9: Foreign Influences</option>
                        <option value="10">Book 10: Greek & Latin</option>
                    </select>
                </div>
                
                <div class="tile-row" id="lessonTiles"></div>

            </div>
            
            <div class="drawer" id="drawer-units">
                <button class="drawer-header" data-drawer="wordUnits">
                    <span>Glued Sounds & Units (Red)</span>
                    <span class="arrow">▼</span>
                </button>
                <div class="drawer-content" id="wordUnits"></div>
            </div>
            
            <div class="drawer" id="drawer-suffixes">
                <button class="drawer-header" data-drawer="affixes">
                    <span>Suffixes (Green)</span>
                    <span class="arrow">▼</span>
                </button>
                <div class="drawer-content" id="affixes"></div>
            </div>
            
            <div class="drawer" id="drawer-prefixes">
                <button class="drawer-header" data-drawer="prefixes">
                    <span>Prefixes & VCE Units (Orange)</span>
                    <span class="arrow">▼</span>
                </button>
                <div class="drawer-content" id="prefixes"></div>
            </div>
            
            <div class="drawer" id="drawer-roots">
                <button class="drawer-header" data-drawer="latin">
                    <span>Latin & Greek Roots (Purple)</span>
                    <span class="arrow">▼</span>
                </button>
                <div class="drawer-content" id="latin"></div>
            </div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 60;
        const SNAP_DISTANCE = 10;

        const B_LEVELS = {
            2: {
                blue: ["b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "qu", "r", "s", "t", "v", "w", "x", "y", "z", "ch", "ck", "sh", "th", "wh"],
                yellow: ["a", "e", "i", "o", "u"]
            },
            3: {
                red: ["all", "ang", "ing", "ong", "ung", "ank", "ink", "onk", "unk", "oll", "old", "olt", "ost", "ild", "ind"]
            },
            4: {
                yellow: ["ai", "ay", "ee", "oa", "oe", "ue", "ew", "ow"]
            },
            5: {
                green: ["s", "es", "ed", "ing", "er", "est", "ist", "y", "en", "ish", "ity", "able", "tion", "sion"],
                orange: ["dis", "in", "un", "non", "mis", "sub", "re", "pre", "inter", "mid", "over", "up"]
            },
            6: {
                blue: ["ph"],
                yellow: ["y"],
                red: ["ture"],
                green: ["ible", "ble", "cle", "dle", "fle", "gle", "kle", "ple", "tle", "zle"],
                orange: ["ate", "ite", "ine", "ice", "ace", "age"]
            },
            7: {
                yellow: ["ar", "or", "er", "ir", "ur", "ear"],
                green: ["ary", "ery", "ory"]
            },
            8: {
                yellow: ["ie", "oi", "oy", "ey", "au", "aw", "oo", "ou", "ow", "ea", "igh", "augh", "eigh", "ei", "eu", "tu"]
            },
            9: {
                blue: ["ps", "rh", "mn", "wr", "kn", "gh", "gn", "que", "gu", "gue"],
                yellow: ["eau", "our"],
                orange: ["age"]
            },
            10: {
                purple: [
                    "astro", "auto", "bio", "chron", "geo", "graph", "hydro", "phon", "tele", "demo",
                    "fac", "form", "fort", "fract", "ject", "jud", "mal", "mater", "mit", "mort",
                    "multi", "pater", "port", "rupt", "scrib", "script", "sect", "sec", "sent", "spect", "struct"
                ]
            }
        };

        let blueTiles = [];
        let yellowTiles = [];
        let redTiles = [];
        let greenTiles = [];
        let orangeTiles = [];
        let purpleTiles = [];
        
        let tiles = [];
        let draggedTile = null;
        let draggedGroup = [];
        let dragOffset = { x: 0, y: 0 };
        
        function getFontSize(text) {
            if (text.length <= 2) return '24px';
            if (text.length === 3) return '20px';
            if (text.length === 4) return '16px';
            if (text.length === 5) return '14px';
            return '12px';
        }
        
        function createTile(text, color, source) {
            const tile = document.createElement('div');
            tile.className = `tile ${color}`;
            tile.textContent = text;
            tile.style.fontSize = getFontSize(text);
            tile.dataset.text = text;
            tile.dataset.color = color;
            tile.dataset.source = source;
            
            tile.addEventListener('mousedown', (e) => handleTileStart(e, text, color, source));
            tile.addEventListener('touchstart', (e) => handleTileStart(e, text, color, source), { passive: false });
            
            return tile;
        }

        function getUniqueSorted(arr) {
            return [...new Set(arr)].sort((a, b) => {
                if (a.length === b.length) {
                    return a.localeCompare(b);
                }
                return a.length - b.length;
            });
        }
        
        function renderTray() {
            const selectedLevel = parseInt(document.getElementById('lessonSelect').value, 10);

            blueTiles = [];
            yellowTiles = [];
            redTiles = [];
            greenTiles = [];
            orangeTiles = [];
            purpleTiles = [];

            for (let i = 2; i <= selectedLevel; i++) {
                if (B_LEVELS[i]) {
                    if (B_LEVELS[i].blue) blueTiles.push(...B_LEVELS[i].blue);
                    if (B_LEVELS[i].yellow) yellowTiles.push(...B_LEVELS[i].yellow);
                    if (B_LEVELS[i].red) redTiles.push(...B_LEVELS[i].red);
                    if (B_LEVELS[i].green) greenTiles.push(...B_LEVELS[i].green);
                    if (B_LEVELS[i].orange) orangeTiles.push(...B_LEVELS[i].orange);
                    if (B_LEVELS[i].purple) purpleTiles.push(...B_LEVELS[i].purple);
                }
            }

            blueTiles = getUniqueSorted(blueTiles);
            yellowTiles = getUniqueSorted(yellowTiles);
            redTiles = getUniqueSorted(redTiles);
            greenTiles = getUniqueSorted(greenTiles);
            orangeTiles = getUniqueSorted(orangeTiles);
            purpleTiles = getUniqueSorted(purpleTiles);

            document.getElementById('lessonTiles').innerHTML = '';
            document.getElementById('wordUnits').innerHTML = '';
            document.getElementById('affixes').innerHTML = '';
            document.getElementById('prefixes').innerHTML = '';
            document.getElementById('latin').innerHTML = '';

            const lessonTilesContainer = document.getElementById('lessonTiles');
            blueTiles.forEach(text => lessonTilesContainer.appendChild(createTile(text, 'blue', 'tray')));
            yellowTiles.forEach(text => lessonTilesContainer.appendChild(createTile(text, 'yellow', 'tray')));

            const drawers = {
                units: { elem: document.getElementById('drawer-units'), tiles: redTiles, color: 'red', container: document.getElementById('wordUnits') },
                suffixes: { elem: document.getElementById('drawer-suffixes'), tiles: greenTiles, color: 'green', container: document.getElementById('affixes') },
                prefixes: { elem: document.getElementById('drawer-prefixes'), tiles: orangeTiles, color: 'orange', container: document.getElementById('prefixes') },
                roots: { elem: document.getElementById('drawer-roots'), tiles: purpleTiles, color: 'purple', container: document.getElementById('latin') }
            };

            for (const key in drawers) {
                const drawer = drawers[key];
                if (drawer.tiles.length > 0) {
                    drawer.elem.classList.remove('hidden');
                    drawer.tiles.forEach(text => drawer.container.appendChild(createTile(text, drawer.color, 'tray')));
                } else {
                    drawer.elem.classList.add('hidden');
                    drawer.container.classList.remove('open');
                    const arrow = drawer.elem.querySelector('.arrow');
                    if (arrow) arrow.textContent = '▼';
                }
            }
        }
        
        function renderWordPane() {
            const wordPane = document.getElementById('wordPane');
            const hint = wordPane.querySelector('.hint');
            
            const existingTiles = wordPane.querySelectorAll('.word-pane-tile');
            existingTiles.forEach(tile => tile.remove());
            
            if (tiles.length > 0) {
                hint.style.display = 'none';
            } else {
                hint.style.display = 'block';
            }
            
            tiles.forEach(tile => {
                // --- MODIFIED ---
                // This check now prevents the "ghosting" effect
                if (draggedGroup.find(t => t.id === tile.id)) return;
                
                const tileEl = document.createElement('div');
                tileEl.className = `tile ${tile.color} word-pane-tile`;
                tileEl.textContent = tile.text;
                tileEl.style.fontSize = getFontSize(tile.text);
                tileEl.style.left = tile.x + 'px';
                tileEl.style.top = tile.y + 'px';
                tileEl.dataset.id = tile.id;
                
                tileEl.addEventListener('mousedown', (e) => handleTileStart(e, tile.text, tile.color, tile.id));
                // --- BUG FIX ---
                // Changed 'text' to 'tile.text'
                tileEl.addEventListener('touchstart', (e) => handleTileStart(e, tile.text, tile.color, tile.id), { passive: false });
                
                wordPane.appendChild(tileEl);
            });
        }
        
        function findNearbyTiles(x, y, excludeId) {
            const nearby = [];
            tiles.forEach(tile => {
                if (tile.id === excludeId) return;
                
                const dy = Math.abs(tile.y - y);
                
                if (dy < TILE_SIZE / 2) {
                    if (Math.abs((tile.x + TILE_SIZE) - x) < SNAP_DISTANCE) {
                        nearby.push({ tile, edge: 'right', snapX: tile.x + TILE_SIZE, snapY: tile.y });
                    }
                    if (Math.abs(tile.x - (x + TILE_SIZE)) < SNAP_DISTANCE) {
                        nearby.push({ tile, edge: 'left', snapX: tile.x - TILE_SIZE, snapY: tile.y });
                    }
                }
            });
            return nearby;
        }
        
        function handleTileStart(e, text, color, source) {
            e.preventDefault();
            e.stopPropagation();
            
            const touch = e.touches ? e.touches[0] : e;
            const rect = e.target.getBoundingClientRect();

            if (source === 'tray') {
                draggedTile = {
                    text: text,
                    color: color,
                    x: touch.clientX,
                    y: touch.clientY,
                    sourceType: 'tray',
                    startX: touch.clientX,
                    startY: touch.clientY
                };
                draggedGroup = []; // Tiles from the tray are never in a group to start
            } else {
                const tile = tiles.find(t => t.id === source);
                draggedTile = {
                    ...tile,
                    x: touch.clientX,
                    y: touch.clientY,
                    sourceType: 'pane',
                    startX: touch.clientX,
                    startY: touch.clientY
                };
                // --- MODIFIED ---
                // Immediately put the dragged tile into the group so it "picks up"
                draggedGroup = [tile]; 
            }
            
            dragOffset = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
            
            updateDragVisual();
        }
        
        function handleMove(e) {
            if (!draggedTile) return;
            e.preventDefault();
            
            const touch = e.touches ? e.touches[0] : e;
            const newX = touch.clientX;
            const newY = touch.clientY;
            
            draggedTile.x = newX;
            draggedTile.y = newY;
            
            // --- MODIFIED ---
            // Simplified the group-finding logic
            if (draggedTile.sourceType === 'pane') {
                const deltaX = newX - draggedTile.startX;
                const deltaY = newY - draggedTile.startY;
                const absDeltaX = Math.abs(deltaX);
                const absDeltaY = Math.abs(deltaY);
                
                if (absDeltaX > 20 || absDeltaY > 20) {
                    if (absDeltaX > absDeltaY) {
                        const currentTile = tiles.find(t => t.id === draggedTile.id);
                        const sameLine = tiles.filter(t => 
                            Math.abs(t.y - currentTile.y) < TILE_SIZE / 2
                        ).sort((a, b) => a.x - b.x);
                        
                        const currentIndex = sameLine.findIndex(t => t.id === draggedTile.id);
                        
                        const hasLeftNeighbor = currentIndex > 0 && 
                            Math.abs(sameLine[currentIndex - 1].x + TILE_SIZE - currentTile.x) < 5;
                        const hasRightNeighbor = currentIndex < sameLine.length - 1 && 
                            Math.abs(currentTile.x + TILE_SIZE - sameLine[currentIndex + 1].x) < 5;
                        
                        if (deltaX < 0 && hasLeftNeighbor) {
                            const group = sameLine.slice(0, currentIndex + 1);
                            draggedGroup = group;
                        } else if (deltaX > 0 && hasRightNeighbor) {
                            const group = sameLine.slice(currentIndex);
                            draggedGroup = group;
                        } else {
                            // It's a single-tile drag, so reset group to just this tile
                            draggedGroup = [currentTile];
                        }
                    }
                }
            }
            
            updateDragVisual();
        }
        
        function handleEnd(e) {
            if (!draggedTile) return;
            e.preventDefault();
            
            const touch = e.changedTouches ? e.changedTouches[0] : e;
            const wordPane = document.getElementById('wordPane');
            const paneRect = wordPane.getBoundingClientRect();
            
            if (touch.clientX >= paneRect.left && 
                touch.clientX <= paneRect.right && 
                touch.clientY >= paneRect.top && 
                touch.clientY <= paneRect.bottom) {
                
                const dropX = touch.clientX - paneRect.left - dragOffset.x;
                const dropY = touch.clientY - paneRect.top - dragOffset.y;
                
                if (draggedTile.sourceType === 'tray') {
                    const nearby = findNearbyTiles(dropX, dropY, draggedTile.id);
                    
                    let finalX = dropX;
                    let finalY = dropY;
                    let groupId = null;
                    
                    if (nearby.length > 0) {
                        const closest = nearby[0];
                        finalX = closest.snapX;
                        finalY = closest.snapY;
                        groupId = closest.tile.groupId || closest.tile.id;
                    }
                    
                    const newTile = {
                        id: Date.now() + Math.random(),
                        text: draggedTile.text,
                        color: draggedTile.color,
                        x: finalX,
                        y: finalY,
                        groupId: groupId
                    };
                    tiles.push(newTile);
                } else {
                    const deltaX = touch.clientX - draggedTile.startX;
                    const deltaY = touch.clientY - draggedTile.startY;
                    
                    if (draggedGroup.length > 0) {
                        // This block now handles both single and group drags
                        tiles = tiles.map(t => {
                            const inGroup = draggedGroup.find(gt => gt.id === t.id);
                            if (inGroup) {
                                // Find the main tile being dragged to get its drop position
                                const mainDraggedTile = draggedGroup.find(gt => gt.id === draggedTile.id);
                                const mainTileDropX = touch.clientX - paneRect.left - (draggedTile.startX - mainDraggedTile.x);
                                const mainTileDropY = touch.clientY - paneRect.top - (draggedTile.startY - mainDraggedTile.y);
                                
                                // Calculate offset from the main dragged tile
                                const tileOffsetX = t.x - mainDraggedTile.x;
                                const tileOffsetY = t.y - mainDraggedTile.y;

                                let finalX = mainTileDropX + tileOffsetX;
                                let finalY = mainTileDropY + tileOffsetY;
                                let groupId = null;

                                // Snap the *main* tile of the group
                                if (t.id === draggedTile.id) {
                                    const nearby = findNearbyTiles(finalX, finalY, draggedTile.id);
                                    if (nearby.length > 0) {
                                        const closest = nearby[0];
                                        finalX = closest.snapX;
                                        finalY = closest.snapY;
                                        groupId = closest.tile.groupId || closest.tile.id;
                                    }
                                }
                                
                                // Apply snapping adjustment to all other tiles in the group
                                if (t.id !== draggedTile.id) {
                                    const mainTile = draggedGroup.find(gt => gt.id === draggedTile.id);
                                    const nearby = findNearbyTiles(mainTile.x, mainTile.y, mainTile.id);
                                    if(nearby.length > 0) {
                                        const closest = nearby[0];
                                        finalX = closest.snapX + (t.x - mainTile.x);
                                        finalY = closest.snapY + (t.y - mainTile.y);
                                        groupId = closest.tile.groupId || closest.tile.id;
                                    }
                                }

                                return { ...t, x: finalX, y: finalY, groupId: groupId };
                            }
                            return t;
                        });

                    } 
                }
            } else if (draggedTile.sourceType === 'pane') {
                if (draggedGroup.length > 0) {
                    tiles = tiles.filter(t => !draggedGroup.find(gt => gt.id === t.id));
                }
            }
            
            draggedTile = null;
            draggedGroup = [];
            clearDragVisual();
            renderWordPane();
        }
        
        function updateDragVisual() {
            clearDragVisual();
            
            if (!draggedTile) return;
            
            const wordPane = document.getElementById('wordPane');
            const paneRect = wordPane.getBoundingClientRect();
            
            if (draggedGroup.length > 0) {
                const deltaX = draggedTile.x - draggedTile.startX;
                const deltaY = draggedTile.y - draggedTile.startY;
                
                draggedGroup.forEach(tile => {
                    const tileEl = document.createElement('div');
                    tileEl.className = `tile ${tile.color} dragging`;
                    tileEl.textContent = tile.text;
                    tileEl.style.fontSize = getFontSize(tile.text);
                    // Use tile's original position + delta
                    tileEl.style.left = (tile.x + deltaX + paneRect.left) + 'px';
                    tileEl.style.top = (tile.y + deltaY + paneRect.top) + 'px';
                    tileEl.dataset.dragging = 'true';
                    document.body.appendChild(tileEl);
                });
            } else { // This block now only runs for tiles from the tray
                const tileEl = document.createElement('div');
                tileEl.className = `tile ${draggedTile.color} dragging`;
                tileEl.textContent = draggedTile.text;
                tileEl.style.fontSize = getFontSize(draggedTile.text);
                tileEl.style.left = (draggedTile.x - dragOffset.x) + 'px';
                tileEl.style.top = (draggedTile.y - dragOffset.y) + 'px';
                tileEl.dataset.dragging = 'true';
                document.body.appendChild(tileEl);
            }
            
            renderWordPane();
        }
        
        function clearDragVisual() {
            document.querySelectorAll('[data-dragging="true"]').forEach(el => el.remove());
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('touchend', handleEnd);
        
        document.querySelectorAll('.drawer-header').forEach(header => {
            header.addEventListener('click', (e) => {
                const drawer = e.currentTarget.closest('.drawer');
                const content = drawer.querySelector('.drawer-content');
                const arrow = e.currentTarget.querySelector('.arrow');
                
                if (content.classList.contains('open')) {
                    content.classList.remove('open');
                    arrow.textContent = '▼';
                } else {
                    content.classList.add('open');
                    arrow.textContent = '▲';
                }
            });
        });

        document.getElementById('lessonSelect').addEventListener('change', renderTray);
        
        renderTray();
        renderWordPane();
    </script>
</body>
</html>
